"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[1131],{41131:(n,e,i)=>{i.r(e),i.d(e,{default:()=>m});i(9950);var t=i(48102),r=i(44414);const a={name:"Selection Sort",description:"Selection Sort is a simple comparison-based sorting algorithm. It divides the input list into two parts: a sorted sublist of items which is built up from left to right, and a sublist of remaining unsorted items. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm repeatedly finds the minimum element from the unsorted sublist and places it at the end of the sorted sublist.",timeComplexityBest:"O(n\xb2)",timeComplexityAverage:"O(n\xb2)",timeComplexityWorst:"O(n\xb2)",spaceComplexity:"O(1)",stability:"Not Stable",implementations:[{language:"javascript",title:"Selection Sort - JavaScript Implementation",code:"function selectionSort(arr) {\n  const n = arr.length;\n  \n  for (let i = 0; i < n - 1; i++) {\n    // Find the minimum element in unsorted array\n    let minIndex = i;\n    \n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    \n    // Swap the found minimum element with the first element\n    if (minIndex !== i) {\n      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n  }\n  \n  return arr;\n}"},{language:"python",title:"Selection Sort - Python Implementation",code:"def selection_sort(arr):\n    n = len(arr)\n    \n    # Traverse through all array elements\n    for i in range(n - 1):\n        # Find the minimum element in remaining unsorted array\n        min_index = i\n        \n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        \n        # Swap the found minimum element with the first element\n        if min_index != i:\n            arr[i], arr[min_index] = arr[min_index], arr[i]\n    \n    return arr"},{language:"java",title:"Selection Sort - Java Implementation",code:"public static void selectionSort(int[] arr) {\n    int n = arr.length;\n    \n    for (int i = 0; i < n - 1; i++) {\n        // Find the minimum element in unsorted array\n        int minIndex = i;\n        \n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        \n        // Swap the found minimum element with the first element\n        if (minIndex != i) {\n            int temp = arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp;\n        }\n    }\n}"},{language:"c++",title:"Selection Sort - C++ Implementation",code:"void selectionSort(vector<int>& arr) {\n    int n = arr.size();\n    \n    for (int i = 0; i < n - 1; i++) {\n        // Find the minimum element in unsorted array\n        int minIndex = i;\n        \n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        \n        // Swap the found minimum element with the first element\n        if (minIndex != i) {\n            swap(arr[i], arr[minIndex]);\n        }\n    }\n}"}]},o=n=>{const e=[],i=[...n],t=i.length;for(let r=0;r<t-1;r++){let n=r;e.push({type:"compare",indices:[r],description:"Starting new pass. Assuming element at index ".concat(r," (value ").concat(i[r],") is the minimum.")});for(let a=r+1;a<t;a++)e.push({type:"compare",indices:[n,a],description:"Comparing minimum ".concat(i[n]," at index ").concat(n," with ").concat(i[a]," at index ").concat(a)}),i[a]<i[n]&&(n=a,e.push({type:"compare",indices:[n],description:"Found new minimum ".concat(i[n]," at index ").concat(n)}));n!==r&&(e.push({type:"swap",indices:[r,n],description:"Swapping ".concat(i[r]," at index ").concat(r," with minimum ").concat(i[n]," at index ").concat(n)}),[i[r],i[n]]=[i[n],i[r]]),e.push({type:"sorted",indices:[r],description:"Element ".concat(i[r]," is now at its correct sorted position at index ").concat(r)})}return e.push({type:"sorted",indices:[t-1],description:"Last element ".concat(i[t-1]," is now at its correct sorted position at index ").concat(t-1)}),e},m=()=>(0,r.jsx)(t.A,{algorithmInfo:a,generateSteps:o})}}]);