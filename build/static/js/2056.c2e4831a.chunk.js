"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[2056],{42056:(n,t,e)=>{e.r(t),e.d(t,{default:()=>c});e(9950);var r=e(48102),i=e(44414);const a={name:"Counting Sort",description:"Counting sort is a non-comparative sorting algorithm that works well when there is limited range of input values. It counts the occurrences of each element and uses this information to place elements in their correct sorted positions. It is particularly efficient when the range of input values is not significantly larger than the number of elements to be sorted.",timeComplexityBest:"O(n + k)",timeComplexityAverage:"O(n + k)",timeComplexityWorst:"O(n + k)",spaceComplexity:"O(n + k)",stability:"Stable",implementations:[{language:"javascript",title:"Counting Sort - JavaScript Implementation",code:"function countingSort(arr) {\n  // Find the maximum element to determine the count array size\n  const max = Math.max(...arr);\n  \n  // Create a count array of size max+1 and initialize with zeros\n  const count = new Array(max + 1).fill(0);\n  \n  // Store the count of each element\n  for (let i = 0; i < arr.length; i++) {\n    count[arr[i]]++;\n  }\n  \n  // Modify the count array to store the position of each element\n  for (let i = 1; i <= max; i++) {\n    count[i] += count[i - 1];\n  }\n  \n  // Create a result array\n  const result = new Array(arr.length);\n  \n  // Build the result array\n  for (let i = arr.length - 1; i >= 0; i--) {\n    result[count[arr[i]] - 1] = arr[i];\n    count[arr[i]]--;\n  }\n  \n  return result;\n}"},{language:"python",title:"Counting Sort - Python Implementation",code:"def counting_sort(arr):\n    # Find the maximum element to determine the count array size\n    max_element = max(arr)\n    \n    # Create a count array of size max+1 and initialize with zeros\n    count = [0] * (max_element + 1)\n    \n    # Store the count of each element\n    for num in arr:\n        count[num] += 1\n    \n    # Modify the count array to store the position of each element\n    for i in range(1, max_element + 1):\n        count[i] += count[i - 1]\n    \n    # Create a result array\n    result = [0] * len(arr)\n    \n    # Build the result array\n    for i in range(len(arr) - 1, -1, -1):\n        result[count[arr[i]] - 1] = arr[i]\n        count[arr[i]] -= 1\n    \n    return result"},{language:"java",title:"Counting Sort - Java Implementation",code:"public static void countingSort(int[] arr) {\n    // Find the maximum element to determine the count array size\n    int max = Arrays.stream(arr).max().getAsInt();\n    \n    // Create a count array of size max+1 and initialize with zeros\n    int[] count = new int[max + 1];\n    \n    // Store the count of each element\n    for (int i = 0; i < arr.length; i++) {\n        count[arr[i]]++;\n    }\n    \n    // Modify the count array to store the position of each element\n    for (int i = 1; i <= max; i++) {\n        count[i] += count[i - 1];\n    }\n    \n    // Create a result array\n    int[] result = new int[arr.length];\n    \n    // Build the result array (process in reverse to maintain stability)\n    for (int i = arr.length - 1; i >= 0; i--) {\n        result[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n    \n    // Copy the result back to the original array\n    for (int i = 0; i < arr.length; i++) {\n        arr[i] = result[i];\n    }\n}"},{language:"c++",title:"Counting Sort - C++ Implementation",code:"void countingSort(vector<int>& arr) {\n    // Find the maximum element to determine the count array size\n    int max = *max_element(arr.begin(), arr.end());\n    \n    // Create a count array of size max+1 and initialize with zeros\n    vector<int> count(max + 1, 0);\n    \n    // Store the count of each element\n    for (int i = 0; i < arr.size(); i++) {\n        count[arr[i]]++;\n    }\n    \n    // Modify the count array to store the position of each element\n    for (int i = 1; i <= max; i++) {\n        count[i] += count[i - 1];\n    }\n    \n    // Create a result array\n    vector<int> result(arr.size());\n    \n    // Build the result array (process in reverse to maintain stability)\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        result[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n    \n    // Copy the result back to the original array\n    for (int i = 0; i < arr.size(); i++) {\n        arr[i] = result[i];\n    }\n}"}]},o=n=>{const t=[],e=[...n];let r=e[0];for(let o=1;o<e.length;o++)t.push({type:"compare",indices:[o,0],description:"Comparing ".concat(e[o]," with current max ").concat(r," to find the maximum value")}),e[o]>r&&(r=e[o],t.push({type:"compare",indices:[o],description:"Found new maximum: ".concat(r)}));const i=new Array(r+1).fill(0);t.push({type:"compare",indices:[],description:"Initialized count array of size ".concat(r+1," with zeros")});for(let o=0;o<e.length;o++)i[e[o]]++,t.push({type:"compare",indices:[o],description:"Counting occurrences of element ".concat(e[o],", count is now ").concat(i[e[o]])});for(let o=1;o<=r;o++)i[o]+=i[o-1],t.push({type:"compare",indices:[],description:"Updating count array at position ".concat(o,": ").concat(i[o-1]," + ").concat(i[o]-i[o-1]," = ").concat(i[o])});const a=new Array(e.length);for(let o=e.length-1;o>=0;o--)t.push({type:"compare",indices:[o],description:"Processing element ".concat(e[o]," at index ").concat(o)}),a[i[e[o]]-1]=e[o],t.push({type:"swap",indices:[o,i[e[o]]-1],description:"Placing ".concat(e[o]," at position ").concat(i[e[o]]-1," in the output array")}),i[e[o]]--;for(let o=0;o<e.length;o++)e[o]=a[o],t.push({type:"sorted",indices:[o],description:"Element ".concat(a[o]," is now in its correct sorted position at index ").concat(o)});return t},c=()=>(0,i.jsx)(r.A,{algorithmInfo:a,generateSteps:o})}}]);