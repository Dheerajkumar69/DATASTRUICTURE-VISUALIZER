"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[8383],{68383:(e,t,n)=>{n.r(t),n.d(t,{default:()=>C});var r,i,a,s=n(89379),o=n(57528),h=n(9950),d=n(44752),l=n(47289),c=n(81535),g=n(66645),p=n(44414);const u=d.Ay.div(r||(r=(0,o.A)(["\n  margin-top: 1rem;\n  display: flex;\n  justify-content: center;\n"]))),m=d.Ay.div(i||(i=(0,o.A)(["\n  padding: 1rem;\n  background-color: ",";\n  transition: all 0.3s ease;\n  border-radius: ",";\n  border: 1px solid ",";\n  margin-bottom: 1rem;\n  box-shadow: ",";\n"])),e=>e.theme.colors.card,e=>e.theme.borderRadius,e=>{let{theme:t}=e;return t.colors.border},e=>e.theme.shadows.sm),f=d.Ay.h3(a||(a=(0,o.A)(["\n  margin-bottom: 0.5rem;\n  color: ",";\n  font-size: 1.2rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid ",";\n"])),e=>e.theme.colors.text,e=>e.theme.colors.border),v={name:"Eulerian Path",description:"An Eulerian path is a path in a graph that visits every edge exactly once. An Eulerian circuit is an Eulerian path that starts and ends on the same vertex. This algorithm finds an Eulerian path if one exists.",timeComplexity:{best:"O(V + E)",average:"O(V + E)",worst:"O(V + E)"},spaceComplexity:"O(V + E)",implementations:{javascript:"function findEulerianPath(graph) {\n  // Find the in-degree and out-degree of each vertex\n  const inDegree = new Array(graph.length).fill(0);\n  const outDegree = graph.map(edges => edges.length);\n  \n  for (let i = 0; i < graph.length; i++) {\n    for (const neighbor of graph[i]) {\n      inDegree[neighbor]++;\n    }\n  }\n  \n  // Check if Eulerian path exists\n  let startVertex = 0;\n  let oddVertices = 0;\n  \n  for (let i = 0; i < graph.length; i++) {\n    if (Math.abs(outDegree[i] - inDegree[i]) > 1) {\n      return []; // No Eulerian path\n    }\n    \n    if (outDegree[i] - inDegree[i] === 1) {\n      startVertex = i;\n      oddVertices++;\n    } else if (inDegree[i] - outDegree[i] === 1) {\n      oddVertices++;\n    }\n  }\n  \n  // For a directed graph to have an Eulerian path:\n  // - Either all vertices have equal in-degree and out-degree (Eulerian circuit)\n  // - Or exactly one vertex has out-degree = in-degree + 1 (start vertex)\n  //   and exactly one vertex has in-degree = out-degree + 1 (end vertex)\n  if (oddVertices > 2) {\n    return []; // No Eulerian path\n  }\n  \n  // Use Hierholzer's algorithm to find the path\n  const path = [];\n  const stack = [startVertex];\n  const tempGraph = graph.map(neighbors => [...neighbors]);\n  \n  while (stack.length > 0) {\n    const current = stack[stack.length - 1];\n    \n    if (tempGraph[current].length > 0) {\n      const next = tempGraph[current].pop();\n      stack.push(next);\n    } else {\n      path.push(stack.pop());\n    }\n  }\n  \n  path.reverse();\n  \n  // Check if all edges were used\n  for (const edges of tempGraph) {\n    if (edges.length > 0) {\n      return []; // Not all edges were used\n    }\n  }\n  \n  return path;\n}",python:"def find_eulerian_path(graph):\n    # Find the in-degree and out-degree of each vertex\n    in_degree = [0] * len(graph)\n    out_degree = [len(edges) for edges in graph]\n    \n    for i in range(len(graph)):\n        for neighbor in graph[i]:\n            in_degree[neighbor] += 1\n    \n    # Check if Eulerian path exists\n    start_vertex = 0\n    odd_vertices = 0\n    \n    for i in range(len(graph)):\n        if abs(out_degree[i] - in_degree[i]) > 1:\n            return []  # No Eulerian path\n        \n        if out_degree[i] - in_degree[i] == 1:\n            start_vertex = i\n            odd_vertices += 1\n        elif in_degree[i] - out_degree[i] == 1:\n            odd_vertices += 1\n    \n    # For a directed graph to have an Eulerian path:\n    # - Either all vertices have equal in-degree and out-degree (Eulerian circuit)\n    # - Or exactly one vertex has out-degree = in-degree + 1 (start vertex)\n    #   and exactly one vertex has in-degree = out-degree + 1 (end vertex)\n    if odd_vertices > 2:\n        return []  # No Eulerian path\n    \n    # Use Hierholzer's algorithm to find the path\n    path = []\n    stack = [start_vertex]\n    temp_graph = [list(neighbors) for neighbors in graph]\n    \n    while stack:\n        current = stack[-1]\n        \n        if temp_graph[current]:\n            next_vertex = temp_graph[current].pop()\n            stack.append(next_vertex)\n        else:\n            path.append(stack.pop())\n    \n    path.reverse()\n    \n    # Check if all edges were used\n    for edges in temp_graph:\n        if edges:\n            return []  # Not all edges were used\n    \n    return path",java:"public List<Integer> findEulerianPath(List<List<Integer>> graph) {\n    // Find the in-degree and out-degree of each vertex\n    int[] inDegree = new int[graph.size()];\n    int[] outDegree = new int[graph.size()];\n    \n    for (int i = 0; i < graph.size(); i++) {\n        outDegree[i] = graph.get(i).size();\n        for (int neighbor : graph.get(i)) {\n            inDegree[neighbor]++;\n        }\n    }\n    \n    // Check if Eulerian path exists\n    int startVertex = 0;\n    int oddVertices = 0;\n    \n    for (int i = 0; i < graph.size(); i++) {\n        if (Math.abs(outDegree[i] - inDegree[i]) > 1) {\n            return new ArrayList<>(); // No Eulerian path\n        }\n        \n        if (outDegree[i] - inDegree[i] == 1) {\n            startVertex = i;\n            oddVertices++;\n        } else if (inDegree[i] - outDegree[i] == 1) {\n            oddVertices++;\n        }\n    }\n    \n    // For a directed graph to have an Eulerian path:\n    // - Either all vertices have equal in-degree and out-degree (Eulerian circuit)\n    // - Or exactly one vertex has out-degree = in-degree + 1 (start vertex)\n    //   and exactly one vertex has in-degree = out-degree + 1 (end vertex)\n    if (oddVertices > 2) {\n        return new ArrayList<>(); // No Eulerian path\n    }\n    \n    // Use Hierholzer's algorithm to find the path\n    List<Integer> path = new ArrayList<>();\n    Stack<Integer> stack = new Stack<>();\n    stack.push(startVertex);\n    \n    // Copy the graph\n    List<List<Integer>> tempGraph = new ArrayList<>();\n    for (List<Integer> edges : graph) {\n        tempGraph.add(new ArrayList<>(edges));\n    }\n    \n    while (!stack.isEmpty()) {\n        int current = stack.peek();\n        \n        if (!tempGraph.get(current).isEmpty()) {\n            int next = tempGraph.get(current).remove(tempGraph.get(current).size() - 1);\n            stack.push(next);\n        } else {\n            path.add(stack.pop());\n        }\n    }\n    \n    Collections.reverse(path);\n    \n    // Check if all edges were used\n    for (List<Integer> edges : tempGraph) {\n        if (!edges.isEmpty()) {\n            return new ArrayList<>(); // Not all edges were used\n        }\n    }\n    \n    return path;\n}",cpp:"vector<int> findEulerianPath(vector<vector<int>>& graph) {\n    // Find the in-degree and out-degree of each vertex\n    vector<int> inDegree(graph.size(), 0);\n    vector<int> outDegree(graph.size(), 0);\n    \n    for (int i = 0; i < graph.size(); i++) {\n        outDegree[i] = graph[i].size();\n        for (int neighbor : graph[i]) {\n            inDegree[neighbor]++;\n        }\n    }\n    \n    // Check if Eulerian path exists\n    int startVertex = 0;\n    int oddVertices = 0;\n    \n    for (int i = 0; i < graph.size(); i++) {\n        if (abs(outDegree[i] - inDegree[i]) > 1) {\n            return {}; // No Eulerian path\n        }\n        \n        if (outDegree[i] - inDegree[i] == 1) {\n            startVertex = i;\n            oddVertices++;\n        } else if (inDegree[i] - outDegree[i] == 1) {\n            oddVertices++;\n        }\n    }\n    \n    // For a directed graph to have an Eulerian path:\n    // - Either all vertices have equal in-degree and out-degree (Eulerian circuit)\n    // - Or exactly one vertex has out-degree = in-degree + 1 (start vertex)\n    //   and exactly one vertex has in-degree = out-degree + 1 (end vertex)\n    if (oddVertices > 2) {\n        return {}; // No Eulerian path\n    }\n    \n    // Use Hierholzer's algorithm to find the path\n    vector<int> path;\n    stack<int> s;\n    s.push(startVertex);\n    \n    // Copy the graph\n    vector<vector<int>> tempGraph = graph;\n    \n    while (!s.empty()) {\n        int current = s.top();\n        \n        if (!tempGraph[current].empty()) {\n            int next = tempGraph[current].back();\n            tempGraph[current].pop_back();\n            s.push(next);\n        } else {\n            path.push_back(s.top());\n            s.pop();\n        }\n    }\n    \n    reverse(path.begin(), path.end());\n    \n    // Check if all edges were used\n    for (const auto& edges : tempGraph) {\n        if (!edges.empty()) {\n            return {}; // Not all edges were used\n        }\n    }\n    \n    return path;\n}"}},x="unvisited",A="visiting",E="visited",b="highlighted",y="normal",w="highlighted",k="discovery",C=()=>{const e=(0,h.useCallback)(e=>{const t=[],{vertices:n,edges:r,adjacencyList:i}=e,a=i.map(e=>[...e]);t.push({vertices:n.map(e=>(0,s.A)((0,s.A)({},e),{},{state:x})),edges:r.map(e=>(0,s.A)((0,s.A)({},e),{},{state:y})),description:"Starting Eulerian Path algorithm"});const o=new Array(n.length).fill(0),h=a.map(e=>e.length);for(let s=0;s<a.length;s++)for(const e of a[s])o[e]++;const d=[];let l=0;for(let f=0;f<n.length;f++){if(Math.abs(h[f]-o[f])>1)return t.push({vertices:n.map(e=>(0,s.A)((0,s.A)({},e),{},{state:x})),edges:r.map(e=>(0,s.A)((0,s.A)({},e),{},{state:y})),description:"No Eulerian path possible: vertex ".concat(String.fromCharCode(65+f)," has |out-degree - in-degree| > 1")}),t;h[f]-o[f]===1?(d.push(f),l=f):o[f]-h[f]===1&&d.push(f)}if(d.length>0&&t.push({vertices:n.map(e=>d.includes(e.id)?(0,s.A)((0,s.A)({},e),{},{state:b}):(0,s.A)((0,s.A)({},e),{},{state:x})),edges:r.map(e=>(0,s.A)((0,s.A)({},e),{},{state:y})),description:2===d.length?"Found vertices with odd degree: ".concat(d.map(e=>String.fromCharCode(65+e)).join(", ")):"All vertices have equal in-degree and out-degree (Eulerian circuit possible)"}),d.length>2)return t.push({vertices:n.map(e=>(0,s.A)((0,s.A)({},e),{},{state:x})),edges:r.map(e=>(0,s.A)((0,s.A)({},e),{},{state:y})),description:"No Eulerian path possible: more than two vertices with odd degree"}),t;const c=new Map;r.forEach(e=>{const t="".concat(e.from,"-").concat(e.to);c.set(t,(0,s.A)({},e))});const g=[],p=[l],u=a.map(e=>[...e]);for(t.push({vertices:n.map(e=>e.id===l?(0,s.A)((0,s.A)({},e),{},{state:A}):d.includes(e.id)?(0,s.A)((0,s.A)({},e),{},{state:b}):(0,s.A)((0,s.A)({},e),{},{state:x})),edges:r.map(e=>(0,s.A)((0,s.A)({},e),{},{state:y})),description:"Starting at vertex ".concat(String.fromCharCode(65+l))});p.length>0;){const e=p[p.length-1];if(u[e].length>0){const i=u[e].pop(),a="".concat(e,"-").concat(i),o=r.map(t=>{if(t.from===e&&t.to===i)return(0,s.A)((0,s.A)({},t),{},{state:k});const n="".concat(t.from,"-").concat(t.to);return c.has(n)?(0,s.A)((0,s.A)({},t),{},{state:y}):(0,s.A)((0,s.A)({},t),{},{state:w})}),h=n.map(t=>t.id===e||t.id===i?(0,s.A)((0,s.A)({},t),{},{state:A}):g.includes(t.id)?(0,s.A)((0,s.A)({},t),{},{state:E}):d.includes(t.id)?(0,s.A)((0,s.A)({},t),{},{state:b}):(0,s.A)((0,s.A)({},t),{},{state:x}));t.push({vertices:h,edges:o,description:"Moving from vertex ".concat(String.fromCharCode(65+e)," to ").concat(String.fromCharCode(65+i))}),c.delete(a),p.push(i)}else{const e=p.pop();g.push(e);const i=n.map(e=>p.length>0&&e.id===p[p.length-1]?(0,s.A)((0,s.A)({},e),{},{state:A}):g.includes(e.id)?(0,s.A)((0,s.A)({},e),{},{state:E}):d.includes(e.id)?(0,s.A)((0,s.A)({},e),{},{state:b}):(0,s.A)((0,s.A)({},e),{},{state:x}));t.push({vertices:i,edges:r.map(e=>{const t="".concat(e.from,"-").concat(e.to);return c.has(t)?(0,s.A)((0,s.A)({},e),{},{state:y}):(0,s.A)((0,s.A)({},e),{},{state:w})}),description:"No more edges from vertex ".concat(String.fromCharCode(65+e),", adding to path")})}}g.reverse();const m=g.map(e=>String.fromCharCode(65+e)).join(" \u2192 ");return t.push({vertices:n.map(e=>(0,s.A)((0,s.A)({},e),{},{state:E})),edges:r.map(e=>(0,s.A)((0,s.A)({},e),{},{state:w})),description:"Eulerian path found: ".concat(m),eulerianPath:g}),t},[x,A,E,b,y,w,k]),t=(0,h.useCallback)(()=>{const e=[],t=[],n=Array(6).fill(0).map(()=>[]);for(let r=0;r<6;r++){const t=2*r*Math.PI/6;e.push({id:r,x:400+220*Math.cos(t),y:300+220*Math.sin(t),name:String.fromCharCode(65+r),state:x})}if(Math.random()<.5){for(let e=0;e<6;e++){const r=(e+1)%6;t.push({from:e,to:r,state:y}),n[e].push(r)}for(let e=0;e<6;e++)for(let r=0;r<6;r++)e!==r&&Math.random()<.2&&(n[e].includes(r)||(t.push({from:e,to:r,state:y}),n[e].push(r)),n[r].includes(e)||(t.push({from:r,to:e,state:y}),n[r].push(e)))}else{const e=0,r=5;for(let i=0;i<5;i++)t.push({from:i,to:i+1,state:y}),n[i].push(i+1);for(let i=0;i<6;i++)for(let a=0;a<6;a++)i!==a&&Math.random()<.2&&(i!==e&&i!==r&&a!==e&&a!==r?(n[i].includes(a)||(t.push({from:i,to:a,state:y}),n[i].push(a)),n[a].includes(i)||(t.push({from:a,to:i,state:y}),n[a].push(i))):(i===e&&a!==r||i!==e&&a===r)&&(n[i].includes(a)||(t.push({from:i,to:a,state:y}),n[i].push(a))))}return{vertices:e,edges:t,adjacencyList:n}},[x,y]),n=(0,p.jsxs)(p.Fragment,{children:[(0,p.jsxs)(m,{children:[(0,p.jsx)(f,{children:"Conditions for Eulerian Path"}),(0,p.jsxs)("ul",{children:[(0,p.jsxs)("li",{children:[(0,p.jsx)("strong",{children:"Directed Graph:"})," Either all vertices have equal in-degree and out-degree (Eulerian circuit), or exactly one vertex has out-degree = in-degree + 1 and exactly one vertex has in-degree = out-degree + 1 (Eulerian path)"]}),(0,p.jsxs)("li",{children:[(0,p.jsx)("strong",{children:"Undirected Graph:"})," Either all vertices have even degree (Eulerian circuit), or exactly two vertices have odd degree (Eulerian path)"]}),(0,p.jsx)("li",{children:"The graph must be connected (excluding isolated vertices)"})]})]}),(0,p.jsxs)(m,{children:[(0,p.jsx)(f,{children:"Hierholzer's Algorithm"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"Start at a vertex with odd out-degree (or any vertex if all have even degree)"}),(0,p.jsx)("li",{children:"Follow edges, deleting them as you go, until you return to the start vertex"}),(0,p.jsx)("li",{children:"If there are unused edges, find a vertex in the current path with unused edges and start a new trail from there"}),(0,p.jsx)("li",{children:"Merge the new trail into the existing path"}),(0,p.jsx)("li",{children:"Repeat until all edges are used"})]})]}),(0,p.jsxs)(m,{children:[(0,p.jsx)(f,{children:"Applications of Eulerian Path"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"Circuit design in electronics"}),(0,p.jsx)("li",{children:"Route planning for garbage collection, snow plowing, and mail delivery"}),(0,p.jsx)("li",{children:"DNA fragment assembly in bioinformatics"}),(0,p.jsx)("li",{children:'Solving the "Seven Bridges of K\xf6nigsberg" problem'}),(0,p.jsx)("li",{children:"Chinese Postman Problem (finding a minimum-cost path that traverses all edges)"})]})]})]}),r=(0,p.jsxs)(p.Fragment,{children:[(0,p.jsx)(g.A,{problemType:"eulerian-path",height:"650px",nodeRadius:25,showEdgeWeights:!1,autoFit:!0,allowZoomPan:!0,generateNewGraph:t,runAlgorithm:e}),(0,p.jsx)(u,{children:(0,p.jsx)(l.s$,{items:[{color:"#E2E8F0",label:"Unvisited Vertex"},{color:"#10B981",label:"Visited Vertex"},{color:"#3B82F6",label:"Current Vertex"},{color:"#F59E0B",label:"Odd Degree Vertex"},{color:"#E2E8F0",label:"Unvisited Edge"},{color:"#10B981",label:"Visited Edge"},{color:"#3B82F6",label:"Current Edge"}]})})]});return(0,p.jsx)(c.A,{algorithmInfo:v,visualizationComponent:r,problemDescription:"\n        <p>An Eulerian path is a path in a graph that visits every edge exactly once. If the path starts and ends at the same vertex, it's called an Eulerian circuit or Eulerian cycle.</p>\n        \n        <p>This concept is named after the famous Swiss mathematician Leonhard Euler, who solved the Seven Bridges of K\xf6nigsberg problem in 1736, laying the foundation for graph theory.</p>\n        \n        <p><strong>For a directed graph to have an Eulerian path:</strong></p>\n        <ul>\n          <li>At most one vertex can have (out-degree) - (in-degree) = 1 (the start vertex)</li>\n          <li>At most one vertex can have (in-degree) - (out-degree) = 1 (the end vertex)</li>\n          <li>All other vertices must have equal in-degree and out-degree</li>\n          <li>All vertices with non-zero degree must be connected in the underlying undirected graph</li>\n        </ul>\n        \n        <p><strong>For an Eulerian circuit to exist:</strong></p>\n        <ul>\n          <li>Every vertex must have equal in-degree and out-degree</li>\n          <li>All vertices with non-zero degree must be connected in the underlying undirected graph</li>\n        </ul>\n        \n        <p>The visualization shows Hierholzer's algorithm, an efficient method for finding Eulerian paths and circuits.</p>\n      ",additionalInfo:n})}}}]);