"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[3010],{93010:(e,t,n)=>{n.r(t),n.d(t,{default:()=>b});var r,s,i,o=n(89379),a=n(57528),d=n(9950),h=n(44752),l=n(47289),c=n(81535),u=n(56607),p=n(44414);const g=h.Ay.div(r||(r=(0,a.A)(["\n  margin-top: 1rem;\n  display: flex;\n  justify-content: center;\n"]))),m=h.Ay.div(s||(s=(0,a.A)(["\n  padding: 1rem;\n  background-color: ",";\n  transition: all 0.3s ease;\n  border-radius: ",";\n  border: 1px solid ",";\n  margin-bottom: 1rem;\n  box-shadow: ",";\n"])),e=>e.theme.colors.card,e=>e.theme.borderRadius,e=>{let{theme:t}=e;return t.colors.border},e=>e.theme.shadows.sm),f=h.Ay.h3(i||(i=(0,a.A)(["\n  margin-bottom: 0.5rem;\n  color: ",";\n  font-size: 1.2rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid ",";\n"])),e=>e.theme.colors.text,e=>e.theme.colors.border),v={name:"Breadth-First Search (BFS)",description:"Breadth-First Search is a graph traversal algorithm that explores all vertices at the present depth before moving on to vertices at the next depth level. It is commonly used to find the shortest path in unweighted graphs.",timeComplexity:{best:"O(V + E)",average:"O(V + E)",worst:"O(V + E)"},spaceComplexity:"O(V)",implementations:{javascript:"function bfs(graph, startNode) {\n  const visited = new Set();\n  const queue = [startNode];\n  const result = [];\n  \n  // Mark the start node as visited\n  visited.add(startNode);\n  \n  while (queue.length > 0) {\n    // Remove the first node from the queue\n    const currentNode = queue.shift();\n    result.push(currentNode);\n    \n    // Visit all adjacent nodes\n    for (const neighbor of graph[currentNode]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  return result;\n}",python:"def bfs(graph, start_node):\n    visited = set()\n    queue = [start_node]\n    result = []\n    \n    # Mark the start node as visited\n    visited.add(start_node)\n    \n    while queue:\n        # Remove the first node from the queue\n        current_node = queue.pop(0)\n        result.append(current_node)\n        \n        # Visit all adjacent nodes\n        for neighbor in graph[current_node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result",java:"public List<Integer> bfs(List<List<Integer>> graph, int startNode) {\n    boolean[] visited = new boolean[graph.size()];\n    Queue<Integer> queue = new LinkedList<>();\n    List<Integer> result = new ArrayList<>();\n    \n    // Mark the start node as visited and enqueue it\n    visited[startNode] = true;\n    queue.add(startNode);\n    \n    while (!queue.isEmpty()) {\n        // Remove the first node from the queue\n        int currentNode = queue.poll();\n        result.add(currentNode);\n        \n        // Visit all adjacent nodes\n        for (int neighbor : graph.get(currentNode)) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                queue.add(neighbor);\n            }\n        }\n    }\n    \n    return result;\n}",cpp:"vector<int> bfs(vector<vector<int>>& graph, int startNode) {\n    vector<bool> visited(graph.size(), false);\n    queue<int> q;\n    vector<int> result;\n    \n    // Mark the start node as visited and enqueue it\n    visited[startNode] = true;\n    q.push(startNode);\n    \n    while (!q.empty()) {\n        // Remove the first node from the queue\n        int currentNode = q.front();\n        q.pop();\n        result.push_back(currentNode);\n        \n        // Visit all adjacent nodes\n        for (int neighbor : graph[currentNode]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    \n    return result;\n}"}},b=()=>{const[e,t]=(0,d.useState)(0),n=(0,d.useCallback)(t=>{const n=[],{vertices:r,edges:s,adjacencyList:i}=t,a="unvisited",d="visiting",h="visited",l="processed",c="normal";n.push({vertices:r.map(e=>(0,o.A)((0,o.A)({},e),{},{state:a})),edges:s.map(e=>(0,o.A)((0,o.A)({},e),{},{state:c})),description:"Starting BFS from node ".concat(String.fromCharCode(65+e))});const u=[e],p=new Set([e]),g=r.map(t=>t.id===e?(0,o.A)((0,o.A)({},t),{},{state:d}):(0,o.A)((0,o.A)({},t),{},{state:a}));for(n.push({vertices:g,edges:s.map(e=>(0,o.A)((0,o.A)({},e),{},{state:c})),description:"Enqueue start node ".concat(String.fromCharCode(65+e)," and mark it as visiting")});u.length>0;){const e=u.shift(),t=r.map(t=>t.id===e?(0,o.A)((0,o.A)({},t),{},{state:l}):p.has(t.id)?(0,o.A)((0,o.A)({},t),{},{state:h}):(0,o.A)((0,o.A)({},t),{},{state:a})),g=s.map(e=>(0,o.A)((0,o.A)({},e),{},{state:c}));n.push({vertices:t,edges:g,description:"Processing node ".concat(String.fromCharCode(65+e))});for(const c of i[e])if(p.has(c)){const t=s.map(t=>t.from===e&&t.to===c||t.bidirectional&&t.from===c&&t.to===e?(0,o.A)((0,o.A)({},t),{},{state:"back"}):(0,o.A)((0,o.A)({},t),{},{state:t.state}));n.push({vertices:n[n.length-1].vertices,edges:t,description:"Node ".concat(String.fromCharCode(65+c)," has already been visited")})}else{const t=s.map(t=>t.from===e&&t.to===c||t.bidirectional&&t.from===c&&t.to===e?(0,o.A)((0,o.A)({},t),{},{state:"discovery"}):(0,o.A)((0,o.A)({},t),{},{state:t.state})),i=r.map(t=>t.id===c?(0,o.A)((0,o.A)({},t),{},{state:d}):t.id===e?(0,o.A)((0,o.A)({},t),{},{state:l}):p.has(t.id)?(0,o.A)((0,o.A)({},t),{},{state:h}):(0,o.A)((0,o.A)({},t),{},{state:a}));n.push({vertices:i,edges:t,description:"Visit neighbor ".concat(String.fromCharCode(65+c)," of node ").concat(String.fromCharCode(65+e))}),u.push(c),p.add(c)}const m=r.map(t=>t.id===e?(0,o.A)((0,o.A)({},t),{},{state:h}):p.has(t.id)?(0,o.A)((0,o.A)({},t),{},{state:t.state}):(0,o.A)((0,o.A)({},t),{},{state:a}));n.push({vertices:m,edges:n[n.length-1].edges,description:"Finished processing node ".concat(String.fromCharCode(65+e))})}return n.push({vertices:r.map(e=>(0,o.A)((0,o.A)({},e),{},{state:p.has(e.id)?h:a})),edges:n[n.length-1].edges,description:"BFS traversal complete"}),n},[e]),r=(0,d.useCallback)(()=>{const e=[],t=[],n=Array(8).fill(0).map(()=>[]),r="normal";for(let s=0;s<8;s++){const t=2*s*Math.PI/8;e.push({id:s,x:400+220*Math.cos(t),y:300+220*Math.sin(t),name:String.fromCharCode(65+s),state:"unvisited"})}for(let s=1;s<8;s++){const e=Math.floor(Math.random()*s);t.push({from:e,to:s,state:r,bidirectional:!0}),n[e].push(s),n[s].push(e)}for(let s=0;s<8;s++)for(let e=s+1;e<8;e++)!n[s].includes(e)&&Math.random()<.2&&(t.push({from:s,to:e,state:r,bidirectional:!0}),n[s].push(e),n[e].push(s));return{vertices:e,edges:t,adjacencyList:n}},[]),s=(0,p.jsxs)(p.Fragment,{children:[(0,p.jsxs)(m,{children:[(0,p.jsx)(f,{children:"How BFS Works"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"BFS uses a queue data structure to keep track of nodes to visit"}),(0,p.jsx)("li",{children:"It starts at a given node and explores all neighbors at the current depth before moving on"}),(0,p.jsx)("li",{children:"BFS guarantees the shortest path in unweighted graphs"}),(0,p.jsx)("li",{children:'It expands outward in "levels" from the starting node'})]})]}),(0,p.jsxs)(m,{children:[(0,p.jsx)(f,{children:"Applications of BFS"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"Finding shortest paths in unweighted graphs"}),(0,p.jsx)("li",{children:"Web crawlers for indexing web pages"}),(0,p.jsx)("li",{children:"Social network friend suggestion algorithms"}),(0,p.jsx)("li",{children:"Puzzle solving (e.g., sliding puzzles, Rubik's cube)"}),(0,p.jsx)("li",{children:"Connected components in undirected graphs"}),(0,p.jsx)("li",{children:"Testing bipartiteness of a graph"})]})]})]}),i=(0,p.jsxs)(p.Fragment,{children:[(0,p.jsx)(u.A,{problemType:"bfs",height:"650px",nodeRadius:25,showEdgeWeights:!1,autoFit:!0,allowZoomPan:!0,generateNewGraph:r,runAlgorithm:n}),(0,p.jsx)(g,{children:(0,p.jsx)(l.s$,{items:[{color:"#E2E8F0",label:"Unvisited"},{color:"#ECC94B",label:"Visiting (In Queue)"},{color:"#3B82F6",label:"Processing"},{color:"#10B981",label:"Visited"},{color:"#6366F1",label:"Discovery Edge"},{color:"#F59E0B",label:"Back Edge"}]})})]});return(0,p.jsx)(c.A,{algorithmInfo:v,visualizationComponent:i,problemDescription:'\n        <p>Breadth-First Search (BFS) is one of the most fundamental graph traversal algorithms. It starts at a given node (the "source" or "root") and explores all neighbor nodes at the present depth level before moving on to nodes at the next depth level.</p>\n        \n        <p>Unlike Depth-First Search (DFS) which explores as far as possible along each branch before backtracking, BFS explores the neighbor nodes first, before moving to the next level neighbors.</p>\n        \n        <p>BFS is implemented using a queue data structure, which follows the First-In-First-Out (FIFO) principle. This ensures that vertices are visited in order of their distance from the source vertex.</p>\n        \n        <p><strong>Key Properties:</strong></p>\n        <ul>\n          <li>BFS finds the shortest path in an unweighted graph</li>\n          <li>It visits nodes in increasing order of their distance from the source</li>\n          <li>It requires O(V+E) time and O(V) space where V is the number of vertices and E is the number of edges</li>\n        </ul>\n      ',additionalInfo:s})}}}]);