"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[4897],{24897:(n,e,t)=>{t.r(e),t.d(e,{default:()=>l});t(9950);var r=t(48102),i=t(44414);const a={name:"Merge Sort",description:"Merge Sort is an efficient, stable, comparison-based, divide and conquer sorting algorithm. It divides the input array into two halves, recursively sorts them, and then merges the sorted halves to produce a sorted output.",timeComplexityBest:"O(n log n)",timeComplexityAverage:"O(n log n)",timeComplexityWorst:"O(n log n)",spaceComplexity:"O(n)",stability:"Stable",implementations:[{language:"javascript",title:"JavaScript Implementation",code:"function mergeSort(arr) {\n  // Base case: arrays with 0 or 1 element are already sorted\n  if (arr.length <= 1) {\n    return arr;\n  }\n  \n  // Divide the array into two halves\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n  \n  // Recursively sort both halves\n  const sortedLeft = mergeSort(left);\n  const sortedRight = mergeSort(right);\n  \n  // Merge the sorted halves\n  return merge(sortedLeft, sortedRight);\n}\n\nfunction merge(left, right) {\n  let result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n  \n  // Compare elements from both arrays and add the smaller one to the result\n  while (leftIndex < left.length && rightIndex < right.length) {\n    if (left[leftIndex] < right[rightIndex]) {\n      result.push(left[leftIndex]);\n      leftIndex++;\n    } else {\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n  }\n  \n  // Add remaining elements from either array\n  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}"},{language:"python",title:"Python Implementation",code:"def merge_sort(arr):\n    # Base case: arrays with 0 or 1 element are already sorted\n    if len(arr) <= 1:\n        return arr\n    \n    # Divide the array into two halves\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Recursively sort both halves\n    left = merge_sort(left)\n    right = merge_sort(right)\n    \n    # Merge the sorted halves\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i, j = 0, 0\n    \n    # Compare elements from both arrays and add the smaller one to the result\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Add remaining elements from either array\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"},{language:"java",title:"Java Implementation",code:"public static void mergeSort(int[] arr, int left, int right) {\n    if (left < right) {\n        // Find the middle point\n        int mid = left + (right - left) / 2;\n        \n        // Sort first and second halves\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        \n        // Merge the sorted halves\n        merge(arr, left, mid, right);\n    }\n}\n\npublic static void merge(int[] arr, int left, int mid, int right) {\n    // Find sizes of two subarrays to be merged\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    \n    // Create temp arrays\n    int[] L = new int[n1];\n    int[] R = new int[n2];\n    \n    // Copy data to temp arrays\n    for (int i = 0; i < n1; ++i)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; ++j)\n        R[j] = arr[mid + 1 + j];\n    \n    // Merge the temp arrays\n    int i = 0, j = 0;\n    int k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    \n    // Copy remaining elements of L[] if any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    \n    // Copy remaining elements of R[] if any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}"},{language:"cpp",title:"C++ Implementation",code:"void merge(int arr[], int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    \n    // Create temp arrays\n    int* L = new int[n1];\n    int* R = new int[n2];\n    \n    // Copy data to temp arrays\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n    \n    // Merge the temp arrays back into arr[left..right]\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    \n    // Copy the remaining elements of L[]\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    \n    // Copy the remaining elements of R[]\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n    \n    delete[] L;\n    delete[] R;\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if (left < right) {\n        // Same as (left+right)/2, but avoids overflow\n        int mid = left + (right - left) / 2;\n        \n        // Sort first and second halves\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        \n        // Merge the sorted halves\n        merge(arr, left, mid, right);\n    }\n}"}]},o=n=>{const e=[],t=[...n],r=(n,t,i)=>{if(t<i){e.push({type:"compare",indices:Array.from({length:i-t+1},(n,e)=>e+t),description:"Dividing array from index ".concat(t," to ").concat(i)});const a=Math.floor((t+i)/2);r(n,t,a),r(n,a+1,i),((n,t,r,i)=>{const a=n.slice(t,r+1),o=n.slice(r+1,i+1);e.push({type:"compare",indices:Array.from({length:i-t+1},(n,e)=>e+t),description:"Merging subarrays from index ".concat(t," to ").concat(r," and from ").concat(r+1," to ").concat(i)});let l=0,s=0,d=t;for(;l<a.length&&s<o.length;)e.push({type:"compare",indices:[t+l,r+1+s],description:"Comparing ".concat(a[l]," and ").concat(o[s])}),a[l]<=o[s]?(e.push({type:"compare",indices:[d],description:"Placing ".concat(a[l]," at position ").concat(d)}),n[d]=a[l],l++):(e.push({type:"compare",indices:[d],description:"Placing ".concat(o[s]," at position ").concat(d)}),n[d]=o[s],s++),d++;for(;l<a.length;)e.push({type:"compare",indices:[d],description:"Placing remaining element ".concat(a[l]," from left subarray at position ").concat(d)}),n[d]=a[l],l++,d++;for(;s<o.length;)e.push({type:"compare",indices:[d],description:"Placing remaining element ".concat(o[s]," from right subarray at position ").concat(d)}),n[d]=o[s],s++,d++;e.push({type:"sorted",indices:Array.from({length:i-t+1},(n,e)=>e+t),description:"Subarray from index ".concat(t," to ").concat(i," is now sorted")})})(n,t,a,i)}else t===i&&e.push({type:"sorted",indices:[t],description:"Single element at index ".concat(t," is already sorted")})};return r(t,0,t.length-1),e},l=()=>(0,i.jsx)(r.A,{algorithmInfo:a,generateSteps:o})}}]);