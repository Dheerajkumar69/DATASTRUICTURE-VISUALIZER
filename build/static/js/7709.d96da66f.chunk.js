"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[7709],{57709:(e,t,n)=>{n.r(t),n.d(t,{default:()=>o});n(9950);var r=n(48102),a=n(44414);const i={name:"Heap Sort",description:"Heap Sort is a comparison-based sorting technique that uses a binary heap data structure. It first builds a max heap (where the largest element is at the root), then repeatedly extracts the maximum element and rebuilds the heap until the array is sorted.",timeComplexityBest:"O(n log n)",timeComplexityAverage:"O(n log n)",timeComplexityWorst:"O(n log n)",spaceComplexity:"O(1)",stability:"Not Stable",implementations:[{language:"javascript",title:"JavaScript Implementation",code:"function heapSort(arr) {\n  const n = arr.length;\n  \n  // Build max heap\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(arr, n, i);\n  }\n  \n  // Extract elements from heap one by one\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root (maximum element) to end\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    \n    // Call heapify on the reduced heap\n    heapify(arr, i, 0);\n  }\n  \n  return arr;\n}\n\nfunction heapify(arr, n, i) {\n  let largest = i;         // Initialize largest as root\n  const left = 2 * i + 1;  // Left child\n  const right = 2 * i + 2; // Right child\n  \n  // If left child is larger than root\n  if (left < n && arr[left] > arr[largest]) {\n    largest = left;\n  }\n  \n  // If right child is larger than largest so far\n  if (right < n && arr[right] > arr[largest]) {\n    largest = right;\n  }\n  \n  // If largest is not root\n  if (largest !== i) {\n    // Swap elements\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    \n    // Recursively heapify the affected sub-tree\n    heapify(arr, n, largest);\n  }\n}"},{language:"python",title:"Python Implementation",code:"def heap_sort(arr):\n    n = len(arr)\n    \n    # Build a max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements one by one\n    for i in range(n - 1, 0, -1):\n        # Swap the root (maximum element) with the last element\n        arr[i], arr[0] = arr[0], arr[i]\n        \n        # Call heapify on the reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr, n, i):\n    largest = i      # Initialize largest as root\n    left = 2 * i + 1 # Left child\n    right = 2 * i + 2 # Right child\n    \n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # If largest is not root\n    if largest != i:\n        # Swap elements\n        arr[i], arr[largest] = arr[largest], arr[i]\n        \n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)"},{language:"java",title:"Java Implementation",code:"public static void heapSort(int[] arr) {\n    int n = arr.length;\n    \n    // Build max heap\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    \n    // Extract elements from heap one by one\n    for (int i = n - 1; i > 0; i--) {\n        // Move current root (maximum element) to end\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        \n        // Call heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\n\nprivate static void heapify(int[] arr, int n, int i) {\n    int largest = i;      // Initialize largest as root\n    int left = 2 * i + 1; // Left child\n    int right = 2 * i + 2; // Right child\n    \n    // If left child is larger than root\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    \n    // If right child is larger than largest so far\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n    \n    // If largest is not root\n    if (largest != i) {\n        // Swap elements\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        \n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}"},{language:"cpp",title:"C++ Implementation",code:"void heapSort(int arr[], int n) {\n    // Build max heap\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    \n    // Extract elements from heap one by one\n    for (int i = n - 1; i > 0; i--) {\n        // Move current root (maximum element) to end\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        \n        // Call heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;      // Initialize largest as root\n    int left = 2 * i + 1; // Left child\n    int right = 2 * i + 2; // Right child\n    \n    // If left child is larger than root\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    \n    // If right child is larger than largest so far\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n    \n    // If largest is not root\n    if (largest != i) {\n        // Swap elements\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        \n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}"}]},l=e=>{const t=[],n=[...e],r=n.length,a=(e,n,r)=>{let i=r;const l=2*r+1;const o=(e=>2*e+2)(r);t.push({type:"compare",indices:[r],description:"Heapifying subtree rooted at index ".concat(r," with value ").concat(e[r])}),l<n&&(t.push({type:"compare",indices:[i,l],description:"Comparing root at index ".concat(i," (value ").concat(e[i],") with left child at index ").concat(l," (value ").concat(e[l],")")}),e[l]>e[i]&&(i=l,t.push({type:"compare",indices:[i],description:"Left child is larger, updating largest to index ".concat(i," with value ").concat(e[i])}))),o<n&&(t.push({type:"compare",indices:[i,o],description:"Comparing current largest at index ".concat(i," (value ").concat(e[i],") with right child at index ").concat(o," (value ").concat(e[o],")")}),e[o]>e[i]&&(i=o,t.push({type:"compare",indices:[i],description:"Right child is larger, updating largest to index ".concat(i," with value ").concat(e[i])}))),i!==r&&(t.push({type:"swap",indices:[r,i],description:"Swapping root at index ".concat(r," (value ").concat(e[r],") with largest child at index ").concat(i," (value ").concat(e[i],")")}),[e[r],e[i]]=[e[i],e[r]],a(e,n,i))};t.push({type:"compare",indices:[],description:"Starting to build max heap"});for(let i=Math.floor(r/2)-1;i>=0;i--)a(n,r,i);t.push({type:"compare",indices:[],description:"Max heap built, starting to extract elements"});for(let i=r-1;i>0;i--)t.push({type:"swap",indices:[0,i],description:"Moving current root (maximum element ".concat(n[0],") to the end at index ").concat(i)}),[n[0],n[i]]=[n[i],n[0]],t.push({type:"sorted",indices:[i],description:"Element at index ".concat(i," with value ").concat(n[i]," is now in its correct sorted position")}),a(n,i,0);return t.push({type:"sorted",indices:[0],description:"Element at index 0 with value ".concat(n[0]," is now in its correct sorted position")}),t.push({type:"sorted",indices:Array.from({length:r},(e,t)=>t),description:"Array is now completely sorted"}),t},o=()=>(0,a.jsx)(r.A,{algorithmInfo:i,generateSteps:l})}}]);