"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[6488],{46488:(e,t,n)=>{n.r(t),n.d(t,{default:()=>b});var i,r,s,a=n(89379),o=n(57528),d=n(9950),c=n(44752),l=n(47289),h=n(81535),g=n(56607),p=n(44414);const f=c.Ay.div(i||(i=(0,o.A)(["\n  margin-top: 1rem;\n  display: flex;\n  justify-content: center;\n"]))),u=c.Ay.div(r||(r=(0,o.A)(["\n  padding: 1rem;\n  background-color: ",";\n  transition: all 0.3s ease;\n  border-radius: ",";\n  border: 1px solid ",";\n  margin-bottom: 1rem;\n  box-shadow: ",";\n"])),e=>e.theme.colors.card,e=>e.theme.borderRadius,e=>{let{theme:t}=e;return t.colors.border},e=>e.theme.shadows.sm),v=c.Ay.h3(s||(s=(0,o.A)(["\n  margin-bottom: 0.5rem;\n  color: ",";\n  font-size: 1.2rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid ",";\n"])),e=>e.theme.colors.text,e=>e.theme.colors.border),m={name:"Directed Graph Cycle Detection",description:"Cycle detection in a directed graph identifies paths that start and end at the same vertex while following directed edges. This algorithm uses Depth-First Search (DFS) with three states of vertices to detect cycles.",timeComplexity:{best:"O(V + E)",average:"O(V + E)",worst:"O(V + E)"},spaceComplexity:"O(V)",implementations:{javascript:"function hasCycle(graph) {\n  // 0: not visited, 1: being visited, 2: visited\n  const state = new Array(graph.length).fill(0);\n  \n  for (let i = 0; i < graph.length; i++) {\n    if (state[i] === 0) {\n      if (dfs(graph, i, state)) {\n        return true;\n      }\n    }\n  }\n  \n  return false;\n}\n\nfunction dfs(graph, vertex, state) {\n  // Mark current node as being visited\n  state[vertex] = 1;\n  \n  // Visit all neighbors\n  for (const neighbor of graph[vertex]) {\n    // If the neighbor is being visited, we found a cycle\n    if (state[neighbor] === 1) {\n      return true;\n    }\n    \n    // If the neighbor hasn't been visited yet\n    if (state[neighbor] === 0) {\n      if (dfs(graph, neighbor, state)) {\n        return true;\n      }\n    }\n  }\n  \n  // Mark current node as visited\n  state[vertex] = 2;\n  return false;\n}",python:"def has_cycle(graph):\n    # 0: not visited, 1: being visited, 2: visited\n    state = [0] * len(graph)\n    \n    for i in range(len(graph)):\n        if state[i] == 0:\n            if dfs(graph, i, state):\n                return True\n    \n    return False\n\ndef dfs(graph, vertex, state):\n    # Mark current node as being visited\n    state[vertex] = 1\n    \n    # Visit all neighbors\n    for neighbor in graph[vertex]:\n        # If the neighbor is being visited, we found a cycle\n        if state[neighbor] == 1:\n            return True\n        \n        # If the neighbor hasn't been visited yet\n        if state[neighbor] == 0:\n            if dfs(graph, neighbor, state):\n                return True\n    \n    # Mark current node as visited\n    state[vertex] = 2\n    return False",java:"public boolean hasCycle(List<List<Integer>> graph) {\n    // 0: not visited, 1: being visited, 2: visited\n    int[] state = new int[graph.size()];\n    \n    for (int i = 0; i < graph.size(); i++) {\n        if (state[i] == 0) {\n            if (dfs(graph, i, state)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nprivate boolean dfs(List<List<Integer>> graph, int vertex, int[] state) {\n    // Mark current node as being visited\n    state[vertex] = 1;\n    \n    // Visit all neighbors\n    for (int neighbor : graph.get(vertex)) {\n        // If the neighbor is being visited, we found a cycle\n        if (state[neighbor] == 1) {\n            return true;\n        }\n        \n        // If the neighbor hasn't been visited yet\n        if (state[neighbor] == 0) {\n            if (dfs(graph, neighbor, state)) {\n                return true;\n            }\n        }\n    }\n    \n    // Mark current node as visited\n    state[vertex] = 2;\n    return false;\n}",cpp:"bool hasCycle(vector<vector<int>>& graph) {\n    // 0: not visited, 1: being visited, 2: visited\n    vector<int> state(graph.size(), 0);\n    \n    for (int i = 0; i < graph.size(); i++) {\n        if (state[i] == 0) {\n            if (dfs(graph, i, state)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nbool dfs(vector<vector<int>>& graph, int vertex, vector<int>& state) {\n    // Mark current node as being visited\n    state[vertex] = 1;\n    \n    // Visit all neighbors\n    for (int neighbor : graph[vertex]) {\n        // If the neighbor is being visited, we found a cycle\n        if (state[neighbor] == 1) {\n            return true;\n        }\n        \n        // If the neighbor hasn't been visited yet\n        if (state[neighbor] == 0) {\n            if (dfs(graph, neighbor, state)) {\n                return true;\n            }\n        }\n    }\n    \n    // Mark current node as visited\n    state[vertex] = 2;\n    return false;\n}"}},b=()=>{const e="unvisited",t="visiting",n="visited",i="normal",r="discovery",s="cycle",o=(0,d.useCallback)(o=>{const d=[],{vertices:c,edges:l,adjacencyList:h}=o;d.push({vertices:c.map(t=>(0,a.A)((0,a.A)({},t),{},{state:e})),edges:l.map(e=>(0,a.A)((0,a.A)({},e),{},{state:i})),description:"Starting directed cycle detection"});const g=new Array(h.length).fill(0),p=new Array(h.length).fill(-1);let f=null;function u(i){g[i]=1;const o=c.map(r=>r.id===i||1===g[r.id]?(0,a.A)((0,a.A)({},r),{},{state:t}):2===g[r.id]?(0,a.A)((0,a.A)({},r),{},{state:n}):(0,a.A)((0,a.A)({},r),{},{state:e}));d.push({vertices:o,edges:[...l],description:"Exploring vertex ".concat(String.fromCharCode(65+i))});for(const e of h[i]){const t=l.map(t=>t.from===i&&t.to===e?(0,a.A)((0,a.A)({},t),{},{state:r}):(0,a.A)((0,a.A)({},t),{},{state:t.state}));if(d.push({vertices:d[d.length-1].vertices,edges:t,description:"Checking edge from ".concat(String.fromCharCode(65+i)," to ").concat(String.fromCharCode(65+e))}),1===g[e]){const n=t.map(t=>t.from===i&&t.to===e?(0,a.A)((0,a.A)({},t),{},{state:s}):(0,a.A)((0,a.A)({},t),{},{state:t.state}));f=[i,e];let r=i;for(;-1!==p[r]&&(f.unshift(p[r]),r=p[r],r!==e););return d.push({vertices:d[d.length-1].vertices,edges:n,description:"Cycle detected! Found back edge from ".concat(String.fromCharCode(65+i)," to ").concat(String.fromCharCode(65+e)),cyclePath:f}),!0}if(0===g[e]&&(p[e]=i,u(e)))return!0;2===g[e]&&d.push({vertices:d[d.length-1].vertices,edges:t,description:"Vertex ".concat(String.fromCharCode(65+e)," already completely explored")})}g[i]=2;const v=d[d.length-1].vertices.map(e=>e.id===i?(0,a.A)((0,a.A)({},e),{},{state:n}):e);return d.push({vertices:v,edges:d[d.length-1].edges,description:"Finished exploring vertex ".concat(String.fromCharCode(65+i))}),!1}for(let e=0;e<h.length&&(0!==g[e]||!u(e));e++);return f||d.push({vertices:d[d.length-1].vertices,edges:d[d.length-1].edges,description:"No cycle found in the directed graph"}),d},[e,t,n,i,r,s]),c=(0,d.useCallback)(()=>{const t=[],n=[],r=Array(7).fill(0).map(()=>[]);for(let i=0;i<7;i++){const n=2*i*Math.PI/7;t.push({id:i,x:400+220*Math.cos(n),y:300+220*Math.sin(n),name:String.fromCharCode(65+i),state:e})}for(let e=0;e<6;e++)n.push({from:e,to:e+1,state:i}),r[e].push(e+1);for(let e=0;e<7;e++)for(let t=0;t<7;t++)e!==t&&!r[e].includes(t)&&Math.random()<.2&&(n.push({from:e,to:t,state:i}),r[e].push(t));if(Math.random()<.7){const e=Math.floor(5*Math.random())+2,t=Math.floor(Math.random()*e);r[e].includes(t)||(n.push({from:e,to:t,state:i}),r[e].push(t))}return{vertices:t,edges:n,adjacencyList:r}},[e,i]),b=(0,p.jsxs)(p.Fragment,{children:[(0,p.jsxs)(u,{children:[(0,p.jsx)(v,{children:"How Directed Cycle Detection Works"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"Uses DFS traversal with three vertex states: unvisited, visiting, and visited"}),(0,p.jsx)("li",{children:'A vertex is marked as "visiting" when first encountered in DFS'}),(0,p.jsx)("li",{children:'If we encounter a "visiting" vertex again during DFS, we\'ve found a cycle'}),(0,p.jsx)("li",{children:'A vertex is marked as "visited" after all its neighbors have been processed'})]})]}),(0,p.jsxs)(u,{children:[(0,p.jsx)(v,{children:"Applications of Directed Cycle Detection"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"Detecting deadlocks in operating systems"}),(0,p.jsx)("li",{children:"Finding circular dependencies in packages or modules"}),(0,p.jsx)("li",{children:"Checking for cyclic dependencies in build systems"}),(0,p.jsx)("li",{children:"Topological sorting (only possible on DAGs - directed acyclic graphs)"}),(0,p.jsx)("li",{children:"Detecting infinite loops in program flow analysis"})]})]})]}),y=(0,p.jsxs)(p.Fragment,{children:[(0,p.jsx)(g.A,{problemType:"directed-cycle",height:"650px",nodeRadius:25,showEdgeWeights:!1,autoFit:!0,allowZoomPan:!0,generateNewGraph:c,runAlgorithm:o}),(0,p.jsx)(f,{children:(0,p.jsx)(l.s$,{items:[{color:"#fff",label:"Unvisited"},{color:"#ECC94B",label:"Visiting (In DFS stack)"},{color:"#10B981",label:"Visited"},{color:"#6366F1",label:"Discovery Edge"},{color:"#EF4444",label:"Cycle Edge"}]})})]});return(0,p.jsx)(h.A,{algorithmInfo:m,visualizationComponent:y,problemDescription:"\n        <p>Cycle detection in directed graphs is a fundamental problem with applications in many fields, including computer science, mathematics, and systems analysis.</p>\n        \n        <p>A cycle in a directed graph is a path of vertices and edges that starts and ends at the same vertex, following the edges in their indicated direction. Unlike undirected graphs, where any edge can be traversed in either direction, in directed graphs, cycles must follow edge directions.</p>\n        \n        <p>This algorithm uses a depth-first search (DFS) approach with a 3-state marking system:</p>\n        <ul>\n          <li><strong>Unvisited:</strong> Vertex has not been processed yet</li>\n          <li><strong>Visiting:</strong> Vertex is currently in the DFS recursion stack</li>\n          <li><strong>Visited:</strong> Vertex and all its descendants have been completely processed</li>\n        </ul>\n        \n        <p>A cycle is detected when, during DFS, we encounter a vertex that is currently in the \"visiting\" state, indicating we've found a path back to a vertex that's still being processed.</p>\n      ",additionalInfo:b})}}}]);