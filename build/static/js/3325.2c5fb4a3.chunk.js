"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[3325],{33325:(e,n,t)=>{t.r(n),t.d(n,{default:()=>x});var r,i,s,o=t(89379),a=t(57528),c=t(9950),d=t(44752),l=t(47289),h=t(81535),f=t(66645),p=t(44414);const g=d.Ay.div(r||(r=(0,a.A)(["\n  margin-top: 1rem;\n  display: flex;\n  justify-content: center;\n"]))),u=d.Ay.div(i||(i=(0,a.A)(["\n  padding: 1rem;\n  background-color: ",";\n  transition: all 0.3s ease;\n  border-radius: ",";\n  border: 1px solid ",";\n  margin-bottom: 1rem;\n  box-shadow: ",";\n"])),e=>e.theme.colors.card,e=>e.theme.borderRadius,e=>{let{theme:n}=e;return n.colors.border},e=>e.theme.shadows.sm),v=d.Ay.h3(s||(s=(0,a.A)(["\n  margin-bottom: 0.5rem;\n  color: ",";\n  font-size: 1.2rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid ",";\n"])),e=>e.theme.colors.text,e=>e.theme.colors.border),m={name:"Undirected Graph Cycle Detection",description:"Cycle detection in an undirected graph is the problem of identifying if a graph contains any cycles, which are paths that start and end at the same vertex. This algorithm uses Depth-First Search (DFS) to detect cycles.",timeComplexity:{best:"O(V + E)",average:"O(V + E)",worst:"O(V + E)"},spaceComplexity:"O(V)",implementations:{javascript:"function hasCycle(graph) {\n  const visited = new Set();\n  \n  function dfs(vertex, parent) {\n    visited.add(vertex);\n    \n    for (const neighbor of graph[vertex]) {\n      // If the neighbor is the parent, skip it\n      if (neighbor === parent) continue;\n      \n      // If the neighbor is already visited, we found a cycle\n      if (visited.has(neighbor)) {\n        return true;\n      }\n      \n      // Recursively check for cycles\n      if (dfs(neighbor, vertex)) {\n        return true;\n      }\n    }\n    \n    return false;\n  }\n  \n  // Check for cycles starting from each unvisited vertex\n  for (let vertex = 0; vertex < graph.length; vertex++) {\n    if (!visited.has(vertex)) {\n      if (dfs(vertex, -1)) {\n        return true;\n      }\n    }\n  }\n  \n  return false;\n}",python:"def has_cycle(graph):\n    visited = set()\n    \n    def dfs(vertex, parent):\n        visited.add(vertex)\n        \n        for neighbor in graph[vertex]:\n            # Skip the parent vertex\n            if neighbor == parent:\n                continue\n            \n            # If the neighbor is already visited, we found a cycle\n            if neighbor in visited:\n                return True\n            \n            # Recursively check for cycles\n            if dfs(neighbor, vertex):\n                return True\n        \n        return False\n    \n    # Check for cycles starting from each unvisited vertex\n    for vertex in range(len(graph)):\n        if vertex not in visited:\n            if dfs(vertex, -1):\n                return True\n    \n    return False",java:"public boolean hasCycle(List<List<Integer>> graph) {\n    Set<Integer> visited = new HashSet<>();\n    \n    for (int vertex = 0; vertex < graph.size(); vertex++) {\n        if (!visited.contains(vertex)) {\n            if (dfs(graph, vertex, -1, visited)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nprivate boolean dfs(List<List<Integer>> graph, int vertex, int parent, Set<Integer> visited) {\n    visited.add(vertex);\n    \n    for (int neighbor : graph.get(vertex)) {\n        // Skip the parent vertex\n        if (neighbor == parent) {\n            continue;\n        }\n        \n        // If the neighbor is already visited, we found a cycle\n        if (visited.contains(neighbor)) {\n            return true;\n        }\n        \n        // Recursively check for cycles\n        if (dfs(graph, neighbor, vertex, visited)) {\n            return true;\n        }\n    }\n    \n    return false;\n}",cpp:"bool hasCycle(vector<vector<int>>& graph) {\n    unordered_set<int> visited;\n    \n    for (int vertex = 0; vertex < graph.size(); vertex++) {\n        if (visited.find(vertex) == visited.end()) {\n            if (dfs(graph, vertex, -1, visited)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nbool dfs(vector<vector<int>>& graph, int vertex, int parent, unordered_set<int>& visited) {\n    visited.insert(vertex);\n    \n    for (int neighbor : graph[vertex]) {\n        // Skip the parent vertex\n        if (neighbor == parent) {\n            continue;\n        }\n        \n        // If the neighbor is already visited, we found a cycle\n        if (visited.find(neighbor) != visited.end()) {\n            return true;\n        }\n        \n        // Recursively check for cycles\n        if (dfs(graph, neighbor, vertex, visited)) {\n            return true;\n        }\n    }\n    \n    return false;\n}"}},x=()=>{const e="unvisited",n="visiting",t="visited",r="normal",i="discovery",s="cycle",a="back",d=(0,c.useCallback)(c=>{const d=[],{vertices:l,edges:h,adjacencyList:f}=c;d.push({vertices:l.map(n=>(0,o.A)((0,o.A)({},n),{},{state:e})),edges:h.map(e=>(0,o.A)((0,o.A)({},e),{},{state:r})),description:"Starting undirected cycle detection"});const p=new Set,g=new Array(f.length).fill(-1);let u=null;function v(r,c){p.add(r);const m=l.map(i=>i.id===r?(0,o.A)((0,o.A)({},i),{},{state:n}):p.has(i.id)?(0,o.A)((0,o.A)({},i),{},{state:t}):(0,o.A)((0,o.A)({},i),{},{state:e}));d.push({vertices:m,edges:[...h],description:"Exploring vertex ".concat(String.fromCharCode(65+r)).concat(-1!==c?" from parent ".concat(String.fromCharCode(65+c)):"")});for(const e of f[r]){if(e===c){const n=h.map(n=>n.from===r&&n.to===e||n.bidirectional&&n.from===e&&n.to===r?(0,o.A)((0,o.A)({},n),{},{state:a}):(0,o.A)((0,o.A)({},n),{},{state:n.state}));d.push({vertices:d[d.length-1].vertices,edges:n,description:"Skipping edge to parent ".concat(String.fromCharCode(65+e))});continue}const n=h.map(n=>n.from===r&&n.to===e||n.bidirectional&&n.from===e&&n.to===r?(0,o.A)((0,o.A)({},n),{},{state:i}):(0,o.A)((0,o.A)({},n),{},{state:n.state}));if(d.push({vertices:d[d.length-1].vertices,edges:n,description:"Checking edge from ".concat(String.fromCharCode(65+r)," to ").concat(String.fromCharCode(65+e))}),p.has(e)){const t=n.map(n=>n.from===r&&n.to===e||n.bidirectional&&n.from===e&&n.to===r?(0,o.A)((0,o.A)({},n),{},{state:s}):(0,o.A)((0,o.A)({},n),{},{state:n.state}));u=[r,e];let i=r;for(;-1!==g[i]&&(u.unshift(g[i]),i=g[i],i!==e););return d.push({vertices:d[d.length-1].vertices,edges:t,description:"Cycle detected! Found back edge from ".concat(String.fromCharCode(65+r)," to ").concat(String.fromCharCode(65+e)),cyclePath:u}),!0}if(!p.has(e)&&(g[e]=r,v(e,r)))return!0}const x=d[d.length-1].vertices.map(e=>e.id===r?(0,o.A)((0,o.A)({},e),{},{state:t}):e);return d.push({vertices:x,edges:d[d.length-1].edges,description:"Finished exploring vertex ".concat(String.fromCharCode(65+r))}),!1}for(let e=0;e<f.length&&(p.has(e)||!v(e,-1));e++);return u||d.push({vertices:d[d.length-1].vertices,edges:d[d.length-1].edges,description:"No cycle found in the undirected graph"}),d},[e,n,t,r,i,s,a]),x=(0,c.useCallback)(()=>{const n=[],t=[],i=Array(7).fill(0).map(()=>[]);for(let r=0;r<7;r++){const t=2*r*Math.PI/7;n.push({id:r,x:400+220*Math.cos(t),y:300+220*Math.sin(t),name:String.fromCharCode(65+r),state:e})}for(let e=1;e<7;e++){const n=Math.floor(Math.random()*e);t.push({from:n,to:e,state:r,bidirectional:!0}),i[n].push(e),i[e].push(n)}for(let e=0;e<7;e++)for(let n=e+1;n<7;n++)!i[e].includes(n)&&Math.random()<.3&&(t.push({from:e,to:n,state:r,bidirectional:!0}),i[e].push(n),i[n].push(e));return{vertices:n,edges:t,adjacencyList:i}},[e,r]),y=(0,p.jsxs)(p.Fragment,{children:[(0,p.jsxs)(u,{children:[(0,p.jsx)(v,{children:"How Undirected Cycle Detection Works"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"Uses DFS traversal to explore the graph"}),(0,p.jsx)("li",{children:"For each vertex, we explore all unvisited neighbors"}),(0,p.jsx)("li",{children:"We keep track of the parent vertex to avoid false cycles"}),(0,p.jsx)("li",{children:"If we encounter an already visited vertex that is not the parent, we've found a cycle"})]})]}),(0,p.jsxs)(u,{children:[(0,p.jsx)(v,{children:"Key Differences from Directed Cycle Detection"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"Must track the parent vertex to avoid considering the edge we just came from as a cycle"}),(0,p.jsx)("li",{children:"In undirected graphs, an edge from A to B is the same as an edge from B to A"}),(0,p.jsx)("li",{children:"All edges are bidirectional, meaning we can move in either direction"})]})]}),(0,p.jsxs)(u,{children:[(0,p.jsx)(v,{children:"Applications of Undirected Cycle Detection"}),(0,p.jsxs)("ul",{children:[(0,p.jsx)("li",{children:"Detecting redundant connections in networks"}),(0,p.jsx)("li",{children:"Verifying that a graph is a tree (a tree is a connected graph with no cycles)"}),(0,p.jsx)("li",{children:"Circuit analysis in electrical engineering"}),(0,p.jsx)("li",{children:"Finding minimal spanning trees in networks"}),(0,p.jsx)("li",{children:"Detecting circular dependencies in systems"})]})]})]}),b=(0,p.jsxs)(p.Fragment,{children:[(0,p.jsx)(f.A,{problemType:"undirected-cycle",height:"650px",nodeRadius:25,showEdgeWeights:!1,autoFit:!0,allowZoomPan:!0,generateNewGraph:x,runAlgorithm:d}),(0,p.jsx)(g,{children:(0,p.jsx)(l.s$,{items:[{color:"#fff",label:"Unvisited"},{color:"#ECC94B",label:"Visiting"},{color:"#10B981",label:"Visited"},{color:"#6366F1",label:"Discovery Edge"},{color:"#EF4444",label:"Cycle Edge"},{color:"#F59E0B",label:"Parent Edge"}]})})]});return(0,p.jsx)(h.A,{algorithmInfo:m,visualizationComponent:b,problemDescription:"\n        <p>Cycle detection in undirected graphs is a fundamental problem with applications in various fields of computer science and engineering.</p>\n        \n        <p>A cycle in an undirected graph is a path of vertices and edges that starts and ends at the same vertex, with no vertices or edges repeated except for the start/end vertex.</p>\n        \n        <p>The algorithm uses depth-first search (DFS) with a key modification:</p>\n        <ul>\n          <li>When visiting neighbors, we ignore the vertex we just came from (the parent)</li>\n          <li>If we encounter an already visited vertex that's not the parent, we've found a cycle</li>\n          <li>This approach properly handles the undirected nature of edges</li>\n        </ul>\n        \n        <p>The algorithm is simple but powerful, with linear time complexity of O(V + E) where V is the number of vertices and E is the number of edges.</p>\n      ",additionalInfo:y})}}}]);