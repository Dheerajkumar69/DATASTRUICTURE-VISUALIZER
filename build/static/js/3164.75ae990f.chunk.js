"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[3164],{53164:(e,n,r)=>{r.r(n),r.d(n,{default:()=>c});r(9950);var t=r(87225),o=r(44414);const l={value:15,left:{value:10,left:{value:8,left:{value:6},right:{value:9}},right:{value:12,left:{value:11}}},right:{value:25,left:{value:20,left:{value:17},right:{value:22}},right:{value:30,left:{value:27}}}},i={name:"Binary Search Tree",description:"A Binary Search Tree (BST) is a node-based binary tree data structure that has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees are also binary search trees. This structure allows for efficient operations like search, insertion, and deletion, typically with O(log n) complexity in balanced trees.",timeComplexity:{best:"O(log n) for search, insert, and delete (balanced tree)",average:"O(log n) for search, insert, and delete",worst:"O(n) for search, insert, and delete (skewed tree)"},spaceComplexity:"O(n) for storing the tree. O(h) for recursive operations, where h is the height of the tree.",implementations:{javascript:"class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  \n  // Insert a value into the BST\n  insert(value) {\n    const newNode = new TreeNode(value);\n    \n    if (this.root === null) {\n      this.root = newNode;\n      return this;\n    }\n    \n    let current = this.root;\n    \n    while (true) {\n      if (value === current.value) return undefined; // No duplicates\n      \n      if (value < current.value) {\n        if (current.left === null) {\n          current.left = newNode;\n          return this;\n        }\n        current = current.left;\n      } else {\n        if (current.right === null) {\n          current.right = newNode;\n          return this;\n        }\n        current = current.right;\n      }\n    }\n  }\n  \n  // Search for a value in the BST\n  search(value) {\n    if (this.root === null) return false;\n    \n    let current = this.root;\n    let found = false;\n    \n    while (current && !found) {\n      if (value < current.value) {\n        current = current.left;\n      } else if (value > current.value) {\n        current = current.right;\n      } else {\n        found = true;\n      }\n    }\n    \n    return found ? current : false;\n  }\n  \n  // Delete a value from the BST\n  delete(value) {\n    this.root = this._deleteNode(this.root, value);\n    return this;\n  }\n  \n  _deleteNode(root, value) {\n    if (root === null) return null;\n    \n    if (value < root.value) {\n      root.left = this._deleteNode(root.left, value);\n    } else if (value > root.value) {\n      root.right = this._deleteNode(root.right, value);\n    } else {\n      // Case 1: Leaf node (no children)\n      if (root.left === null && root.right === null) {\n        return null;\n      }\n      \n      // Case 2: Node with only one child\n      if (root.left === null) {\n        return root.right;\n      }\n      if (root.right === null) {\n        return root.left;\n      }\n      \n      // Case 3: Node with two children\n      // Find the minimum value in the right subtree\n      let successor = this._findMin(root.right);\n      root.value = successor.value;\n      \n      // Delete the successor\n      root.right = this._deleteNode(root.right, successor.value);\n    }\n    \n    return root;\n  }\n  \n  _findMin(node) {\n    while (node.left !== null) {\n      node = node.left;\n    }\n    return node;\n  }\n}",python:"class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n    \n    # Insert a value into the BST\n    def insert(self, value):\n        if self.root is None:\n            self.root = TreeNode(value)\n            return\n            \n        current = self.root\n        \n        while True:\n            if value == current.value:\n                return  # No duplicates\n            \n            if value < current.value:\n                if current.left is None:\n                    current.left = TreeNode(value)\n                    return\n                current = current.left\n            else:\n                if current.right is None:\n                    current.right = TreeNode(value)\n                    return\n                current = current.right\n    \n    # Search for a value in the BST\n    def search(self, value):\n        current = self.root\n        \n        while current:\n            if value == current.value:\n                return True\n            \n            if value < current.value:\n                current = current.left\n            else:\n                current = current.right\n                \n        return False\n    \n    # Delete a value from the BST\n    def delete(self, value):\n        self.root = self._delete_node(self.root, value)\n        \n    def _delete_node(self, root, value):\n        if root is None:\n            return None\n            \n        if value < root.value:\n            root.left = self._delete_node(root.left, value)\n        elif value > root.value:\n            root.right = self._delete_node(root.right, value)\n        else:\n            # Case 1: Leaf node (no children)\n            if root.left is None and root.right is None:\n                return None\n                \n            # Case 2: Node with only one child\n            if root.left is None:\n                return root.right\n            if root.right is None:\n                return root.left\n                \n            # Case 3: Node with two children\n            # Find the minimum value in the right subtree\n            successor = self._find_min(root.right)\n            root.value = successor.value\n            \n            # Delete the successor\n            root.right = self._delete_node(root.right, successor.value)\n            \n        return root\n        \n    def _find_min(self, node):\n        current = node\n        while current.left:\n            current = current.left\n        return current",java:"class TreeNode {\n    int value;\n    TreeNode left;\n    TreeNode right;\n    \n    public TreeNode(int value) {\n        this.value = value;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass BinarySearchTree {\n    TreeNode root;\n    \n    public BinarySearchTree() {\n        this.root = null;\n    }\n    \n    // Insert a value into the BST\n    public void insert(int value) {\n        if (root == null) {\n            root = new TreeNode(value);\n            return;\n        }\n        \n        TreeNode current = root;\n        \n        while (true) {\n            if (value == current.value) {\n                return; // No duplicates\n            }\n            \n            if (value < current.value) {\n                if (current.left == null) {\n                    current.left = new TreeNode(value);\n                    return;\n                }\n                current = current.left;\n            } else {\n                if (current.right == null) {\n                    current.right = new TreeNode(value);\n                    return;\n                }\n                current = current.right;\n            }\n        }\n    }\n    \n    // Search for a value in the BST\n    public boolean search(int value) {\n        TreeNode current = root;\n        \n        while (current != null) {\n            if (value == current.value) {\n                return true;\n            }\n            \n            if (value < current.value) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n        \n        return false;\n    }\n    \n    // Delete a value from the BST\n    public void delete(int value) {\n        root = deleteNode(root, value);\n    }\n    \n    private TreeNode deleteNode(TreeNode root, int value) {\n        if (root == null) {\n            return null;\n        }\n        \n        if (value < root.value) {\n            root.left = deleteNode(root.left, value);\n        } else if (value > root.value) {\n            root.right = deleteNode(root.right, value);\n        } else {\n            // Case 1: Leaf node (no children)\n            if (root.left == null && root.right == null) {\n                return null;\n            }\n            \n            // Case 2: Node with only one child\n            if (root.left == null) {\n                return root.right;\n            }\n            if (root.right == null) {\n                return root.left;\n            }\n            \n            // Case 3: Node with two children\n            // Find the minimum value in the right subtree\n            TreeNode successor = findMin(root.right);\n            root.value = successor.value;\n            \n            // Delete the successor\n            root.right = deleteNode(root.right, successor.value);\n        }\n        \n        return root;\n    }\n    \n    private TreeNode findMin(TreeNode node) {\n        TreeNode current = node;\n        while (current.left != null) {\n            current = current.left;\n        }\n        return current;\n    }\n}",cpp:"struct TreeNode {\n    int value;\n    TreeNode* left;\n    TreeNode* right;\n    \n    TreeNode(int val) : value(val), left(nullptr), right(nullptr) {}\n};\n\nclass BinarySearchTree {\nprivate:\n    TreeNode* root;\n    \n    TreeNode* deleteNode(TreeNode* root, int value) {\n        if (root == nullptr) return nullptr;\n        \n        if (value < root->value) {\n            root->left = deleteNode(root->left, value);\n        } else if (value > root->value) {\n            root->right = deleteNode(root->right, value);\n        } else {\n            // Case 1: Leaf node (no children)\n            if (root->left == nullptr && root->right == nullptr) {\n                delete root;\n                return nullptr;\n            }\n            \n            // Case 2: Node with only one child\n            if (root->left == nullptr) {\n                TreeNode* temp = root->right;\n                delete root;\n                return temp;\n            }\n            if (root->right == nullptr) {\n                TreeNode* temp = root->left;\n                delete root;\n                return temp;\n            }\n            \n            // Case 3: Node with two children\n            // Find the minimum value in the right subtree\n            TreeNode* successor = findMin(root->right);\n            root->value = successor->value;\n            \n            // Delete the successor\n            root->right = deleteNode(root->right, successor->value);\n        }\n        \n        return root;\n    }\n    \n    TreeNode* findMin(TreeNode* node) {\n        TreeNode* current = node;\n        while (current->left != nullptr) {\n            current = current->left;\n        }\n        return current;\n    }\n    \npublic:\n    BinarySearchTree() : root(nullptr) {}\n    \n    ~BinarySearchTree() {\n        // Clean up code to delete all nodes (not shown)\n    }\n    \n    // Insert a value into the BST\n    void insert(int value) {\n        if (root == nullptr) {\n            root = new TreeNode(value);\n            return;\n        }\n        \n        TreeNode* current = root;\n        \n        while (true) {\n            if (value == current->value) {\n                return; // No duplicates\n            }\n            \n            if (value < current->value) {\n                if (current->left == nullptr) {\n                    current->left = new TreeNode(value);\n                    return;\n                }\n                current = current->left;\n            } else {\n                if (current->right == nullptr) {\n                    current->right = new TreeNode(value);\n                    return;\n                }\n                current = current->right;\n            }\n        }\n    }\n    \n    // Search for a value in the BST\n    bool search(int value) {\n        TreeNode* current = root;\n        \n        while (current != nullptr) {\n            if (value == current->value) {\n                return true;\n            }\n            \n            if (value < current->value) {\n                current = current->left;\n            } else {\n                current = current->right;\n            }\n        }\n        \n        return false;\n    }\n    \n    // Delete a value from the BST\n    void remove(int value) {\n        root = deleteNode(root, value);\n    }\n}"}},a=e=>{if(e)return{value:e.value,left:a(e.left),right:a(e.right)}},u=e=>function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:17;const r=[],t=[];r.push({tree:a(e),currentNode:null,visitedNodes:[],description:"Starting search for value ".concat(n," in the BST. We'll compare with each node and go left if the target is smaller, right if it's larger.")});const o=function(l){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return l?(t.push(l.value),r.push({tree:a(e),currentNode:l.value,visitedNodes:[...t],description:"".concat(i,"Comparing target value ").concat(n," with current node value ").concat(l.value,".")}),n===l.value?(r.push({tree:a(e),currentNode:l.value,visitedNodes:[...t],description:"".concat(i,"Found the target value ").concat(n,"!")}),!0):n<l.value?(r.push({tree:a(e),currentNode:l.value,visitedNodes:[...t],description:"".concat(i,"Value ").concat(n," is less than ").concat(l.value,", moving to the left subtree.")}),o(l.left,i+"  ")):(r.push({tree:a(e),currentNode:l.value,visitedNodes:[...t],description:"".concat(i,"Value ").concat(n," is greater than ").concat(l.value,", moving to the right subtree.")}),o(l.right,i+"  "))):(r.push({tree:a(e),currentNode:null,visitedNodes:[...t],description:"".concat(i,"Node is null. Value ").concat(n," not found in this path.")}),!1)},l=o(e);return r.push({tree:a(e),currentNode:null,visitedNodes:[...t],description:"Search complete. Value ".concat(n," ").concat(l?"was found":"was not found"," in the BST.")}),r}(e),c=()=>(0,o.jsx)(t.A,{algorithmInfo:i,initialTree:l,generateSteps:u})},80771:(e,n,r)=>{r.d(n,{A:()=>t});const t={'code[class*="language-"]':{color:"#ccc",background:"none",fontFamily:"Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",fontSize:"1em",textAlign:"left",whiteSpace:"pre",wordSpacing:"normal",wordBreak:"normal",wordWrap:"normal",lineHeight:"1.5",MozTabSize:"4",OTabSize:"4",tabSize:"4",WebkitHyphens:"none",MozHyphens:"none",msHyphens:"none",hyphens:"none"},'pre[class*="language-"]':{color:"#ccc",background:"#2d2d2d",fontFamily:"Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",fontSize:"1em",textAlign:"left",whiteSpace:"pre",wordSpacing:"normal",wordBreak:"normal",wordWrap:"normal",lineHeight:"1.5",MozTabSize:"4",OTabSize:"4",tabSize:"4",WebkitHyphens:"none",MozHyphens:"none",msHyphens:"none",hyphens:"none",padding:"1em",margin:".5em 0",overflow:"auto"},':not(pre) > code[class*="language-"]':{background:"#2d2d2d",padding:".1em",borderRadius:".3em",whiteSpace:"normal"},comment:{color:"#999"},"block-comment":{color:"#999"},prolog:{color:"#999"},doctype:{color:"#999"},cdata:{color:"#999"},punctuation:{color:"#ccc"},tag:{color:"#e2777a"},"attr-name":{color:"#e2777a"},namespace:{color:"#e2777a"},deleted:{color:"#e2777a"},"function-name":{color:"#6196cc"},boolean:{color:"#f08d49"},number:{color:"#f08d49"},function:{color:"#f08d49"},property:{color:"#f8c555"},"class-name":{color:"#f8c555"},constant:{color:"#f8c555"},symbol:{color:"#f8c555"},selector:{color:"#cc99cd"},important:{color:"#cc99cd",fontWeight:"bold"},atrule:{color:"#cc99cd"},keyword:{color:"#cc99cd"},builtin:{color:"#cc99cd"},string:{color:"#7ec699"},char:{color:"#7ec699"},"attr-value":{color:"#7ec699"},regex:{color:"#7ec699"},variable:{color:"#7ec699"},operator:{color:"#67cdcc"},entity:{color:"#67cdcc",cursor:"help"},url:{color:"#67cdcc"},bold:{fontWeight:"bold"},italic:{fontStyle:"italic"},inserted:{color:"green"}}},87225:(e,n,r)=>{r.d(n,{A:()=>Y});var t,o,l,i,a,u,c,s,d,h,f,v,g,m,p,N,y,b,x,T,w=r(57528),S=r(9950),A=r(44752),j=r(54826),k=r(42074),C=r(28925),M=r(80771),_=r(44414);const B=A.Ay.div(t||(t=(0,w.A)(["\n  padding: 2rem;\n  max-width: 1200px;\n  margin: 0 auto;\n"]))),z=A.Ay.div(o||(o=(0,w.A)(["\n  position: sticky;\n  top: 0;\n  background: ",";\n  padding: 1rem 0;\n  z-index: 100;\n"])),e=>{let{theme:n}=e;return n.colors.card}),I=A.Ay.div(l||(l=(0,w.A)(["\n  display: flex;\n  align-items: center;\n  margin-bottom: 1rem;\n"]))),P=(0,A.Ay)(k.N_)(i||(i=(0,w.A)(["\n  display: flex;\n  align-items: center;\n  text-decoration: none;\n  color: ",";\n  font-size: 0.9rem;\n  margin-right: 1rem;\n  \n  &:hover {\n    color: #007bff;\n  }\n"])),e=>{let{theme:n}=e;return n.colors.text}),W=A.Ay.h1(a||(a=(0,w.A)(["\n  margin: 0;\n  font-size: 2rem;\n  color: ",";\n"])),e=>{let{theme:n}=e;return n.colors.text}),D=A.Ay.div(u||(u=(0,w.A)(["\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 2rem;\n  margin-top: 2rem;\n  \n  @media (max-width: 768px) {\n    grid-template-columns: 1fr;\n  }\n"]))),H=A.Ay.div(c||(c=(0,w.A)(["\n  background: ",";\n  border-radius: 8px;\n  padding: 1.5rem;\n  min-height: 400px;\n"])),e=>{let{theme:n}=e;return n.colors.gray100}),F=A.Ay.div(s||(s=(0,w.A)(["\n  height: 300px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  margin-bottom: 1rem;\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  overflow: hidden;\n"]))),O=A.Ay.button(d||(d=(0,w.A)(["\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.5rem 1rem;\n  border: none;\n  border-radius: 4px;\n  background: ",";\n  color: ",";\n  cursor: pointer;\n  transition: background 0.3s ease;\n  \n  &:hover {\n    background: ",";\n  }\n  \n  &:disabled {\n    background: #ccc;\n    cursor: not-allowed;\n  }\n"])),e=>{let{theme:n}=e;return n.colors.primary},e=>{let{theme:n}=e;return n.colors.card},e=>{let{theme:n}=e;return n.colors.primaryDark}),L=A.Ay.div(h||(h=(0,w.A)(["\n  display: flex;\n  gap: 1rem;\n  margin-bottom: 1rem;\n"]))),R=A.Ay.div(f||(f=(0,w.A)(["\n  margin-top: 1rem;\n  padding: 1rem;\n  background: ",";\n  border-radius: 4px;\n  font-size: 0.9rem;\n"])),e=>{let{theme:n}=e;return n.colors.gray200}),E=A.Ay.div(v||(v=(0,w.A)(["\n  background: ",";\n  border-radius: 8px;\n  padding: 1.5rem;\n  overflow: auto;\n"])),e=>{let{theme:n}=e;return n.colors.gray100}),V=A.Ay.div(g||(g=(0,w.A)(["\n  margin-bottom: 2rem;\n"]))),U=A.Ay.div(m||(m=(0,w.A)(["\n  margin-bottom: 1rem;\n"]))),K=A.Ay.h3(p||(p=(0,w.A)(["\n  margin: 0 0 0.5rem 0;\n  color: ",";\n"])),e=>{let{theme:n}=e;return n.colors.text}),q=A.Ay.p(N||(N=(0,w.A)(["\n  margin: 0;\n  color: ",";\n  line-height: 1.6;\n"])),e=>{let{theme:n}=e;return n.colors.textLight}),G=A.Ay.div(y||(y=(0,w.A)(["\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 1rem;\n  margin-bottom: 1rem;\n  \n  @media (max-width: 768px) {\n    grid-template-columns: 1fr;\n  }\n"]))),J=A.Ay.div(b||(b=(0,w.A)(["\n  background: ",";\n  padding: 1rem;\n  border-radius: 4px;\n"])),e=>{let{theme:n}=e;return n.colors.gray100}),Q=A.Ay.div(x||(x=(0,w.A)(["\n  font-size: 0.8rem;\n  color: ",";\n  margin-bottom: 0.5rem;\n"])),e=>{let{theme:n}=e;return n.colors.textLight}),X=A.Ay.div(T||(T=(0,w.A)(["\n  font-weight: bold;\n  color: ",";\n"])),e=>{let{theme:n}=e;return n.colors.text}),Y=e=>{let{algorithmInfo:n,initialTree:r,generateSteps:t}=e;const[o,l]=(0,S.useState)(r),[i,a]=(0,S.useState)([]),[u,c]=(0,S.useState)(0),[s,d]=(0,S.useState)(!1),[h,f]=(0,S.useState)(!1),[v,g]=(0,S.useState)(1e3),[m,p]=(0,S.useState)("Click Start to begin visualization"),[N,y]=(0,S.useState)("javascript"),b=(0,S.useRef)(null),x=(0,S.useRef)();(0,S.useEffect)(()=>{const e=t(r);a(e);const n=b.current;return n&&T(r,n),()=>{x.current&&clearTimeout(x.current)}},[r,t]),(0,S.useEffect)(()=>{if(s&&!h&&u<i.length){const e=i[u];p(e.description);const n=b.current;n&&T(e.tree,n,e.currentNode,e.visitedNodes),x.current=setTimeout(()=>{u<i.length-1?c(e=>e+1):d(!1)},v)}return()=>{x.current&&clearTimeout(x.current)}},[s,h,u,i,v]);const T=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];const o=n.getContext("2d");if(!o)return;o.clearRect(0,0,n.width,n.height),n.width=n.clientWidth,n.height=n.clientHeight;const l=e=>e?1+Math.max(l(e.left),l(e.right)):0,i=l(e),a=20,u=n.height/(i+1),c=n.width/2,s=(e,n,l,i,c)=>{if(!e)return;o.beginPath(),e.value===r?o.fillStyle="#ff9800":t.includes(e.value)?o.fillStyle="#4caf50":o.fillStyle="#2196f3",o.arc(n,l,a,0,2*Math.PI),o.fill(),o.fillStyle="white",o.font="12px Arial",o.textAlign="center",o.textBaseline="middle",o.fillText(e.value.toString(),n,l);const d=c/2;if(e.left){const r=n-d,c=l+u;o.beginPath(),o.strokeStyle=t.includes(e.value)&&t.includes(e.left.value)?"#4caf50":"#aaaaaa",o.lineWidth=2,o.moveTo(n-a*Math.cos(Math.PI/4),l+a*Math.sin(Math.PI/4)),o.lineTo(r+a*Math.cos(Math.PI/4),c-a*Math.sin(Math.PI/4)),o.stroke(),s(e.left,r,c,i+1,d)}if(e.right){const r=n+d,c=l+u;o.beginPath(),o.strokeStyle=t.includes(e.value)&&t.includes(e.right.value)?"#4caf50":"#aaaaaa",o.lineWidth=2,o.moveTo(n+a*Math.cos(Math.PI/4),l+a*Math.sin(Math.PI/4)),o.lineTo(r-a*Math.cos(Math.PI/4),c-a*Math.sin(Math.PI/4)),o.stroke(),s(e.right,r,c,i+1,d)}};s(e,c,30,0,n.width/2)};return(0,_.jsxs)(B,{children:[(0,_.jsxs)(z,{children:[(0,_.jsx)(I,{children:(0,_.jsx)(P,{to:"/data-structures/tree",children:"\u2190 Back to Trees"})}),(0,_.jsx)(W,{children:n.name})]}),(0,_.jsxs)(V,{children:[(0,_.jsxs)(U,{children:[(0,_.jsx)(K,{children:"Description"}),(0,_.jsx)(q,{children:n.description})]}),(0,_.jsxs)(G,{children:[(0,_.jsxs)(J,{children:[(0,_.jsx)(Q,{children:"Best Case"}),(0,_.jsx)(X,{children:n.timeComplexity.best})]}),(0,_.jsxs)(J,{children:[(0,_.jsx)(Q,{children:"Average Case"}),(0,_.jsx)(X,{children:n.timeComplexity.average})]}),(0,_.jsxs)(J,{children:[(0,_.jsx)(Q,{children:"Worst Case"}),(0,_.jsx)(X,{children:n.timeComplexity.worst})]})]}),(0,_.jsxs)(U,{children:[(0,_.jsx)(K,{children:"Space Complexity"}),(0,_.jsx)(q,{children:n.spaceComplexity})]})]}),(0,_.jsxs)(D,{children:[(0,_.jsxs)(H,{children:[(0,_.jsx)(F,{children:(0,_.jsx)("canvas",{ref:b,width:600,height:300,style:{width:"100%",height:"100%"}})}),(0,_.jsxs)(L,{children:[(0,_.jsxs)(O,{onClick:s?()=>{f(!0),x.current&&clearTimeout(x.current)}:()=>{h||(c(0),d(!0)),f(!1)},disabled:s&&!h,children:[s&&!h?(0,_.jsx)(j.kwt,{}):(0,_.jsx)(j.gSK,{}),s&&!h?"Pause":"Start"]}),(0,_.jsxs)(O,{onClick:()=>{if(u<i.length-1){const e=i[u+1];c(e=>e+1),p(e.description);const n=b.current;n&&T(e.tree,n,e.currentNode,e.visitedNodes)}},disabled:!s||h||u>=i.length-1,children:[(0,_.jsx)(j.FH8,{}),"Step"]}),(0,_.jsxs)(O,{onClick:()=>{d(!1),f(!1),c(0),p("Click Start to begin visualization");const e=b.current;e&&T(r,e),x.current&&clearTimeout(x.current)},children:[(0,_.jsx)(j.EEI,{}),"Reset"]})]}),(0,_.jsx)(R,{children:m})]}),(0,_.jsxs)(E,{children:[(0,_.jsx)(K,{children:"Implementation"}),(0,_.jsxs)("div",{children:[(0,_.jsx)(L,{children:Object.keys(n.implementations).map(e=>(0,_.jsx)(O,{onClick:()=>y(e),style:{background:N===e?"#007bff":"#6c757d"},children:e.charAt(0).toUpperCase()+e.slice(1)},e))}),(0,_.jsx)(C.A,{language:N,style:M.A,children:n.implementations[N]})]})]})]})]})}}}]);