"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[8592],{88592:(n,t,e)=>{e.r(t),e.d(t,{default:()=>h});e(9950);var i=e(48102),r=e(44414);const o={name:"Quick Sort",description:'Quick Sort is an efficient, in-place, divide-and-conquer sorting algorithm. It works by selecting a "pivot" element and partitioning the array around the pivot, recursively sorting the resulting sub-arrays.',timeComplexityBest:"O(n log n)",timeComplexityAverage:"O(n log n)",timeComplexityWorst:"O(n\xb2)",spaceComplexity:"O(log n)",stability:"Not Stable",implementations:[{language:"javascript",title:"JavaScript Implementation",code:"function quickSort(arr, low = 0, high = arr.length - 1) {\n  if (low < high) {\n    // Partition the array and get the pivot index\n    const pivotIndex = partition(arr, low, high);\n    \n    // Recursively sort the sub-arrays\n    quickSort(arr, low, pivotIndex - 1);\n    quickSort(arr, pivotIndex + 1, high);\n  }\n  \n  return arr;\n}\n\nfunction partition(arr, low, high) {\n  // Choose the rightmost element as the pivot\n  const pivot = arr[high];\n  \n  // Index of smaller element\n  let i = low - 1;\n  \n  // Compare each element with pivot\n  for (let j = low; j < high; j++) {\n    // If current element is smaller than the pivot\n    if (arr[j] < pivot) {\n      // Increment index of smaller element\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  \n  // Place the pivot element at its correct position\n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n  \n  // Return the position where partition is done\n  return i + 1;\n}"},{language:"python",title:"Python Implementation",code:"def quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition the array and get the pivot index\n        pivot_index = partition(arr, low, high)\n        \n        # Recursively sort the sub-arrays\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    # Choose the rightmost element as the pivot\n    pivot = arr[high]\n    \n    # Index of smaller element\n    i = low - 1\n    \n    # Compare each element with pivot\n    for j in range(low, high):\n        # If current element is smaller than the pivot\n        if arr[j] < pivot:\n            # Increment index of smaller element\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Place the pivot element at its correct position\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    \n    # Return the position where partition is done\n    return i + 1"},{language:"java",title:"Java Implementation",code:"public static void quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        // Partition the array and get the pivot index\n        int pivotIndex = partition(arr, low, high);\n        \n        // Recursively sort the sub-arrays\n        quickSort(arr, low, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, high);\n    }\n}\n\npublic static int partition(int[] arr, int low, int high) {\n    // Choose the rightmost element as the pivot\n    int pivot = arr[high];\n    \n    // Index of smaller element\n    int i = low - 1;\n    \n    // Compare each element with pivot\n    for (int j = low; j < high; j++) {\n        // If current element is smaller than the pivot\n        if (arr[j] < pivot) {\n            // Increment index of smaller element\n            i++;\n            \n            // Swap arr[i] and arr[j]\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    \n    // Place the pivot element at its correct position\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    \n    // Return the position where partition is done\n    return i + 1;\n}"},{language:"cpp",title:"C++ Implementation",code:"void quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        // Partition the array and get the pivot index\n        int pivotIndex = partition(arr, low, high);\n        \n        // Recursively sort the sub-arrays\n        quickSort(arr, low, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, high);\n    }\n}\n\nint partition(int arr[], int low, int high) {\n    // Choose the rightmost element as the pivot\n    int pivot = arr[high];\n    \n    // Index of smaller element\n    int i = low - 1;\n    \n    // Compare each element with pivot\n    for (int j = low; j < high; j++) {\n        // If current element is smaller than the pivot\n        if (arr[j] < pivot) {\n            // Increment index of smaller element\n            i++;\n            \n            // Swap arr[i] and arr[j]\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    \n    // Place the pivot element at its correct position\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    \n    // Return the position where partition is done\n    return i + 1;\n}"}]},a=n=>{const t=[],e=[...n],i=(n,e,r)=>{if(e<r){t.push({type:"compare",indices:Array.from({length:r-e+1},(n,t)=>t+e),description:"Processing subarray from index ".concat(e," to ").concat(r)});const o=((n,e,i)=>{const r=n[i];t.push({type:"compare",indices:[i],description:"Choosing element at index ".concat(i," with value ").concat(r," as pivot")});let o=e-1;for(let h=e;h<i;h++)t.push({type:"compare",indices:[h,i],description:"Comparing element at index ".concat(h," (").concat(n[h],") with pivot (").concat(r,")")}),n[h]<r&&(o++,o!==h&&(t.push({type:"swap",indices:[o,h],description:"Swapping elements at indices ".concat(o," (").concat(n[o],") and ").concat(h," (").concat(n[h],")")}),[n[o],n[h]]=[n[h],n[o]]));const a=o+1;return a!==i&&(t.push({type:"swap",indices:[a,i],description:"Placing pivot at its correct position: swapping elements at indices ".concat(a," (").concat(n[a],") and ").concat(i," (").concat(n[i],")")}),[n[a],n[i]]=[n[i],n[a]]),t.push({type:"sorted",indices:[a],description:"Pivot element ".concat(r," is now at its correct sorted position at index ").concat(a)}),a})(n,e,r);i(n,e,o-1),i(n,o+1,r)}else e===r&&t.push({type:"sorted",indices:[e],description:"Single element at index ".concat(e," is already sorted")})};return i(e,0,e.length-1),t.push({type:"sorted",indices:Array.from({length:e.length},(n,t)=>t),description:"Array is now completely sorted"}),t},h=()=>(0,r.jsx)(i.A,{algorithmInfo:o,generateSteps:a})}}]);