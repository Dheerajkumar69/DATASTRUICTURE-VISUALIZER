"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[8350],{38350:(n,e,r)=>{r.r(e),r.d(e,{default:()=>mn});var t,o,i,d,a,s,c,l,h,m,g,u,p,w,f,x,b,y,v,A,j=r(57528),S=r(9950),W=r(44752),k=r(54826),C=r(42074),q=r(28925),z=r(80771),L=r(44414);const _=W.Ay.div(t||(t=(0,j.A)(["\n  padding: 2rem;\n  max-width: 1200px;\n  margin: 0 auto;\n"]))),I=W.Ay.div(o||(o=(0,j.A)(["\n  position: sticky;\n  top: 0;\n  background: ",";\n  padding: 1rem 0;\n  z-index: 100;\n"])),n=>{let{theme:e}=n;return e.colors.card}),T=W.Ay.div(i||(i=(0,j.A)(["\n  display: flex;\n  align-items: center;\n  margin-bottom: 1rem;\n"]))),H=(0,W.Ay)(C.N_)(d||(d=(0,j.A)(["\n  display: flex;\n  align-items: center;\n  text-decoration: none;\n  color: ",";\n  font-size: 0.9rem;\n  margin-right: 1rem;\n  \n  &:hover {\n    color: #007bff;\n  }\n"])),n=>{let{theme:e}=n;return e.colors.text}),F=W.Ay.h1(a||(a=(0,j.A)(["\n  margin: 0;\n  font-size: 2rem;\n  color: ",";\n"])),n=>{let{theme:e}=n;return e.colors.text}),M=W.Ay.div(s||(s=(0,j.A)(["\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 2rem;\n  margin-top: 2rem;\n  \n  @media (max-width: 768px) {\n    grid-template-columns: 1fr;\n  }\n"]))),B=W.Ay.div(c||(c=(0,j.A)(["\n  background: ",";\n  border-radius: 8px;\n  padding: 1.5rem;\n  min-height: 400px;\n"])),n=>{let{theme:e}=n;return e.colors.gray100}),O=W.Ay.div(l||(l=(0,j.A)(["\n  margin-bottom: 1.5rem;\n  line-height: 1.5;\n"]))),P=W.Ay.button(h||(h=(0,j.A)(["\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.5rem 1rem;\n  border: none;\n  border-radius: 4px;\n  background: ",";\n  color: ",";\n  cursor: pointer;\n  transition: background 0.3s ease;\n  \n  &:hover {\n    background: ",";\n  }\n  \n  &:disabled {\n    background: #ccc;\n    cursor: not-allowed;\n  }\n"])),n=>{let{theme:e}=n;return e.colors.primary},n=>{let{theme:e}=n;return e.colors.card},n=>{let{theme:e}=n;return e.colors.primaryDark}),R=W.Ay.div(m||(m=(0,j.A)(["\n  display: flex;\n  gap: 1rem;\n  margin-bottom: 1.5rem;\n"]))),D=W.Ay.div(g||(g=(0,j.A)(["\n  background: ",";\n  border-radius: 8px;\n  padding: 1.5rem;\n  overflow: auto;\n"])),n=>{let{theme:e}=n;return e.colors.gray100}),E=W.Ay.div(u||(u=(0,j.A)(["\n  margin-bottom: 2rem;\n"]))),U=W.Ay.div(p||(p=(0,j.A)(["\n  margin-bottom: 1rem;\n"]))),K=W.Ay.h3(w||(w=(0,j.A)(["\n  margin: 0 0 0.5rem 0;\n  color: ",";\n"])),n=>{let{theme:e}=n;return e.colors.text}),G=W.Ay.p(f||(f=(0,j.A)(["\n  margin: 0;\n  color: ",";\n  line-height: 1.5;\n"])),n=>{let{theme:e}=n;return e.colors.textLight}),N=W.Ay.div(x||(x=(0,j.A)(["\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 1rem;\n  margin-bottom: 1rem;\n  \n  @media (max-width: 768px) {\n    grid-template-columns: 1fr;\n  }\n"]))),Q=W.Ay.div(b||(b=(0,j.A)(["\n  background: ",";\n  padding: 1rem;\n  border-radius: 4px;\n"])),n=>{let{theme:e}=n;return e.colors.gray100}),V=W.Ay.div(y||(y=(0,j.A)(["\n  font-size: 0.8rem;\n  color: ",";\n  margin-bottom: 0.5rem;\n"])),n=>{let{theme:e}=n;return e.colors.textLight}),J=W.Ay.div(v||(v=(0,j.A)(["\n  font-weight: bold;\n  color: ",";\n"])),n=>{let{theme:e}=n;return e.colors.text}),X=W.Ay.div(A||(A=(0,j.A)(["\n  height: 300px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  margin-bottom: 1rem;\n  position: relative;\n  overflow: hidden;\n"]))),Y=n=>{let{algorithmInfo:e,visualizationComponent:r,problemDescription:t}=n;const[o,i]=(0,S.useState)("javascript");return(0,L.jsxs)(_,{children:[(0,L.jsxs)(I,{children:[(0,L.jsx)(T,{children:(0,L.jsx)(H,{to:"/algorithms/problems",children:"\u2190 Back to Problems"})}),(0,L.jsx)(F,{children:e.name})]}),(0,L.jsxs)(E,{children:[(0,L.jsxs)(U,{children:[(0,L.jsx)(K,{children:"Description"}),(0,L.jsx)(G,{children:e.description})]}),(0,L.jsxs)(O,{children:[(0,L.jsx)(K,{children:"Problem"}),(0,L.jsx)(G,{children:t})]}),(0,L.jsxs)(N,{children:[(0,L.jsxs)(Q,{children:[(0,L.jsx)(V,{children:"Best Case"}),(0,L.jsx)(J,{children:e.timeComplexity.best})]}),(0,L.jsxs)(Q,{children:[(0,L.jsx)(V,{children:"Average Case"}),(0,L.jsx)(J,{children:e.timeComplexity.average})]}),(0,L.jsxs)(Q,{children:[(0,L.jsx)(V,{children:"Worst Case"}),(0,L.jsx)(J,{children:e.timeComplexity.worst})]})]}),(0,L.jsxs)(U,{children:[(0,L.jsx)(K,{children:"Space Complexity"}),(0,L.jsx)(G,{children:e.spaceComplexity})]})]}),(0,L.jsxs)(M,{children:[(0,L.jsxs)(B,{children:[(0,L.jsx)(X,{children:r}),(0,L.jsxs)(R,{children:[(0,L.jsxs)(P,{children:[(0,L.jsx)(k.gSK,{}),"Play"]}),(0,L.jsxs)(P,{children:[(0,L.jsx)(k.kwt,{}),"Pause"]}),(0,L.jsxs)(P,{children:[(0,L.jsx)(k.FH8,{}),"Step"]}),(0,L.jsxs)(P,{children:[(0,L.jsx)(k.EEI,{}),"Reset"]})]})]}),(0,L.jsxs)(D,{children:[(0,L.jsx)(K,{children:"Implementation"}),(0,L.jsxs)("div",{children:[(0,L.jsx)(R,{children:Object.keys(e.implementations).map(n=>(0,L.jsx)(P,{onClick:()=>i(n),style:{background:o===n?"#007bff":"#6c757d"},children:n.charAt(0).toUpperCase()+n.slice(1)},n))}),(0,L.jsx)(q.A,{language:o,style:z.A,children:e.implementations[o]})]})]})]})]})};var Z,$,nn,en,rn,tn,on,dn,an,sn,cn,ln;W.Ay.div(Z||(Z=(0,j.A)(["\n  display: flex;\n  gap: 1rem;\n  margin-bottom: 1.5rem;\n  flex-wrap: wrap;\n  width: 100%;\n  justify-content: center;\n"]))),W.Ay.div($||($=(0,j.A)(["\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n  min-width: 200px;\n"]))),W.Ay.label(nn||(nn=(0,j.A)(["\n  font-size: 0.9rem;\n  color: ",";\n  font-weight: 500;\n"])),n=>n.theme.colors.textLight),W.Ay.div(en||(en=(0,j.A)(["\n  padding: 0.75rem 1.5rem;\n  margin: 0.5rem;\n  background-color: ",";\n  transition: all 0.3s ease;\n  color: ",";\n  border-radius: ",";\n  border: 1px solid ",";\n  font-weight: bold;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1;\n"])),n=>{switch(n.state){case"current":return n.theme.colors.primary;case"visited":return n.theme.colors.secondary;case"path":return n.theme.colors.success;case"start":return n.theme.colors.info;case"end":return n.theme.colors.warning;case"rejected":return n.theme.colors.danger;default:return n.theme.colors.background}},n=>"unvisited"===n.state?n.theme.colors.text:"white",n=>n.theme.borderRadius,n=>{let{theme:e}=n;return e.colors.border}),W.Ay.span(rn||(rn=(0,j.A)(["\n  position: absolute;\n  top: -8px;\n  right: -8px;\n  background-color: ",";\n  transition: all 0.3s ease;\n  color: ",";\n  border-radius: 50%;\n  width: 20px;\n  height: 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 0.75rem;\n"])),n=>n.theme.colors.textLight,n=>{let{theme:e}=n;return e.colors.card}),W.Ay.div(tn||(tn=(0,j.A)(["\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  margin: 1.5rem 0;\n  width: 100%;\n"]))),W.Ay.div(on||(on=(0,j.A)(["\n  display: flex;\n  align-items: center;\n  color: ",";\n  margin: 0 0.5rem;\n"])),n=>n.theme.colors.textLight),W.Ay.div(dn||(dn=(0,j.A)(["\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  gap: 0.75rem;\n  margin-top: 1.5rem;\n  padding: 1rem;\n  border-radius: ",";\n  border: 1px solid ",";\n  background-color: rgba(0, 0, 0, 0.02);\n  transition: all 0.3s ease;\n"])),n=>n.theme.borderRadius,n=>{let{theme:e}=n;return e.colors.border}),W.Ay.div(an||(an=(0,j.A)(["\n  margin-top: 1.5rem;\n  border-top: 1px solid ",";\n  padding-top: 1.5rem;\n"])),n=>n.theme.colors.border),W.Ay.textarea(sn||(sn=(0,j.A)(["\n  width: 300px;\n  height: 100px;\n  border: 1px solid ",";\n  border-radius: ",";\n  border: 1px solid ",";\n  padding: 0.75rem;\n  font-size: 0.9rem;\n"])),n=>n.theme.colors.border,n=>n.theme.borderRadius,n=>{let{theme:e}=n;return e.colors.border}),W.Ay.div(cn||(cn=(0,j.A)(["\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin: 0.5rem;\n"]))),W.Ay.span(ln||(ln=(0,j.A)(["\n  font-size: 0.7rem;\n  margin-top: 0.25rem;\n  color: ",";\n  font-weight: bold;\n"])),n=>n.theme.colors.textLight);const hn={name:"Word Ladder",description:"Word Ladder is a graph problem where we need to find the shortest transformation sequence from a start word to an end word, such that only one letter can be changed at a time, and each transformed word must exist in a given word list.",timeComplexity:{best:"O(n * m^2)",average:"O(n * m^2)",worst:"O(n * m^2)"},spaceComplexity:"O(n * m)",implementations:{javascript:"function ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  \n  // If the end word is not in the dictionary, return 0\n  if (!wordSet.has(endWord)) return 0;\n  \n  // Create a queue for BFS\n  const queue = [];\n  queue.push({ word: beginWord, length: 1 });\n  \n  // To avoid visiting the same word again\n  const visited = new Set();\n  visited.add(beginWord);\n  \n  while (queue.length > 0) {\n    const { word, length } = queue.shift();\n    \n    // Try changing each character of the word\n    for (let i = 0; i < word.length; i++) {\n      // Try replacing the character with all letters\n      for (let c = 'a'.charCodeAt(0); c <= 'z'.charCodeAt(0); c++) {\n        const newChar = String.fromCharCode(c);\n        \n        // Skip if it's the same character\n        if (word[i] === newChar) continue;\n        \n        // Create a new word by replacing the character\n        const newWord = word.slice(0, i) + newChar + word.slice(i + 1);\n        \n        // If we reached the end word, return the length + 1\n        if (newWord === endWord) return length + 1;\n        \n        // If the word is in the dictionary and not visited\n        if (wordSet.has(newWord) && !visited.has(newWord)) {\n          visited.add(newWord);\n          queue.push({ word: newWord, length: length + 1 });\n        }\n      }\n    }\n  }\n  \n  // If no transformation sequence is found\n  return 0;\n}",python:"def ladder_length(begin_word, end_word, word_list):\n    word_set = set(word_list)\n    \n    # If the end word is not in the dictionary, return 0\n    if end_word not in word_set:\n        return 0\n    \n    # Create a queue for BFS\n    queue = [(begin_word, 1)]\n    \n    # To avoid visiting the same word again\n    visited = {begin_word}\n    \n    while queue:\n        word, length = queue.pop(0)\n        \n        # Try changing each character of the word\n        for i in range(len(word)):\n            # Try replacing the character with all letters\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                # Skip if it's the same character\n                if word[i] == c:\n                    continue\n                \n                # Create a new word by replacing the character\n                new_word = word[:i] + c + word[i+1:]\n                \n                # If we reached the end word, return the length + 1\n                if new_word == end_word:\n                    return length + 1\n                \n                # If the word is in the dictionary and not visited\n                if new_word in word_set and new_word not in visited:\n                    visited.add(new_word)\n                    queue.append((new_word, length + 1))\n    \n    # If no transformation sequence is found\n    return 0",java:"public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> wordSet = new HashSet<>(wordList);\n    \n    // If the end word is not in the dictionary, return 0\n    if (!wordSet.contains(endWord)) return 0;\n    \n    // Create a queue for BFS\n    Queue<Pair<String, Integer>> queue = new LinkedList<>();\n    queue.offer(new Pair<>(beginWord, 1));\n    \n    // To avoid visiting the same word again\n    Set<String> visited = new HashSet<>();\n    visited.add(beginWord);\n    \n    while (!queue.isEmpty()) {\n        Pair<String, Integer> current = queue.poll();\n        String word = current.getKey();\n        int length = current.getValue();\n        \n        // Try changing each character of the word\n        for (int i = 0; i < word.length(); i++) {\n            char[] wordChars = word.toCharArray();\n            \n            // Try replacing the character with all letters\n            for (char c = 'a'; c <= 'z'; c++) {\n                // Skip if it's the same character\n                if (word.charAt(i) == c) continue;\n                \n                wordChars[i] = c;\n                String newWord = new String(wordChars);\n                \n                // If we reached the end word, return the length + 1\n                if (newWord.equals(endWord)) return length + 1;\n                \n                // If the word is in the dictionary and not visited\n                if (wordSet.contains(newWord) && !visited.contains(newWord)) {\n                    visited.add(newWord);\n                    queue.offer(new Pair<>(newWord, length + 1));\n                }\n            }\n        }\n    }\n    \n    // If no transformation sequence is found\n    return 0;\n}",cpp:"int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n    unordered_set<string> wordSet(wordList.begin(), wordList.end());\n    \n    // If the end word is not in the dictionary, return 0\n    if (wordSet.find(endWord) == wordSet.end()) return 0;\n    \n    // Create a queue for BFS\n    queue<pair<string, int>> q;\n    q.push({beginWord, 1});\n    \n    // To avoid visiting the same word again\n    unordered_set<string> visited;\n    visited.insert(beginWord);\n    \n    while (!q.empty()) {\n        auto current = q.front(); q.pop();\n        string word = current.first;\n        int length = current.second;\n        \n        // Try changing each character of the word\n        for (int i = 0; i < word.size(); i++) {\n            char originalChar = word[i];\n            \n            // Try replacing the character with all letters\n            for (char c = 'a'; c <= 'z'; c++) {\n                // Skip if it's the same character\n                if (word[i] == c) continue;\n                \n                word[i] = c;\n                \n                // If we reached the end word, return the length + 1\n                if (word == endWord) return length + 1;\n                \n                // If the word is in the dictionary and not visited\n                if (wordSet.find(word) != wordSet.end() && visited.find(word) == visited.end()) {\n                    visited.insert(word);\n                    q.push({word, length + 1});\n                }\n            }\n            \n            // Revert the change\n            word[i] = originalChar;\n        }\n    }\n    \n    // If no transformation sequence is found\n    return 0;\n}"}},mn=()=>{const n=(0,L.jsx)("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",height:"100%"},children:(0,L.jsx)("p",{children:"Word transformation visualization will be displayed here"})});return(0,L.jsx)(Y,{algorithmInfo:hn,visualizationComponent:n,problemDescription:'\nGiven two words, beginWord and endWord, and a dictionary wordList, find the length of the shortest transformation sequence from beginWord to endWord.\n\nRules for transformation:\n1. Only one letter can be changed at a time.\n2. Each transformed word must exist in the wordList.\n3. beginWord is not a part of wordList, but endWord is.\n\nFor example, given:\n- beginWord = "hit"\n- endWord = "cog"\n- wordList = ["hot", "dot", "dog", "lot", "log", "cog"]\n\nThe shortest transformation sequence would be: "hit" -> "hot" -> "dot" -> "dog" -> "cog"\nSo the length of the shortest transformation sequence is 5.\n\nThe algorithm uses a breadth-first search (BFS) approach to find the shortest path from beginWord to endWord. For each word, it tries changing each character to every possible letter and checks if the new word exists in the dictionary and hasn\'t been visited yet.\n'})}},80771:(n,e,r)=>{r.d(e,{A:()=>t});const t={'code[class*="language-"]':{color:"#ccc",background:"none",fontFamily:"Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",fontSize:"1em",textAlign:"left",whiteSpace:"pre",wordSpacing:"normal",wordBreak:"normal",wordWrap:"normal",lineHeight:"1.5",MozTabSize:"4",OTabSize:"4",tabSize:"4",WebkitHyphens:"none",MozHyphens:"none",msHyphens:"none",hyphens:"none"},'pre[class*="language-"]':{color:"#ccc",background:"#2d2d2d",fontFamily:"Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",fontSize:"1em",textAlign:"left",whiteSpace:"pre",wordSpacing:"normal",wordBreak:"normal",wordWrap:"normal",lineHeight:"1.5",MozTabSize:"4",OTabSize:"4",tabSize:"4",WebkitHyphens:"none",MozHyphens:"none",msHyphens:"none",hyphens:"none",padding:"1em",margin:".5em 0",overflow:"auto"},':not(pre) > code[class*="language-"]':{background:"#2d2d2d",padding:".1em",borderRadius:".3em",whiteSpace:"normal"},comment:{color:"#999"},"block-comment":{color:"#999"},prolog:{color:"#999"},doctype:{color:"#999"},cdata:{color:"#999"},punctuation:{color:"#ccc"},tag:{color:"#e2777a"},"attr-name":{color:"#e2777a"},namespace:{color:"#e2777a"},deleted:{color:"#e2777a"},"function-name":{color:"#6196cc"},boolean:{color:"#f08d49"},number:{color:"#f08d49"},function:{color:"#f08d49"},property:{color:"#f8c555"},"class-name":{color:"#f8c555"},constant:{color:"#f8c555"},symbol:{color:"#f8c555"},selector:{color:"#cc99cd"},important:{color:"#cc99cd",fontWeight:"bold"},atrule:{color:"#cc99cd"},keyword:{color:"#cc99cd"},builtin:{color:"#cc99cd"},string:{color:"#7ec699"},char:{color:"#7ec699"},"attr-value":{color:"#7ec699"},regex:{color:"#7ec699"},variable:{color:"#7ec699"},operator:{color:"#67cdcc"},entity:{color:"#67cdcc",cursor:"help"},url:{color:"#67cdcc"},bold:{fontWeight:"bold"},italic:{fontStyle:"italic"},inserted:{color:"green"}}}}]);