"use strict";(self.webpackChunkdata_structure_visualizer=self.webpackChunkdata_structure_visualizer||[]).push([[5864],{85864:(e,n,t)=>{t.r(n),t.d(n,{default:()=>_});var i,s,r,o,l,a,c,d,h,g,m,p,x,u,f,v,y,j=t(89379),A=t(57528),b=t(9950),k=t(44752),w=t(54826),E=t(42074),S=t(44414);const C=k.Ay.div(i||(i=(0,A.A)(["\n  display: flex;\n  flex-direction: column;\n  padding: 20px;\n  max-width: 1200px;\n  margin: 0 auto;\n"]))),F=k.Ay.div(s||(s=(0,A.A)(["\n  display: flex;\n  align-items: center;\n  margin-bottom: 20px;\n"]))),T=(0,k.Ay)(E.N_)(r||(r=(0,A.A)(["\n  display: flex;\n  align-items: center;\n  text-decoration: none;\n  color: #3182ce;\n  margin-right: auto;\n  \n  &:hover {\n    text-decoration: underline;\n  }\n"]))),M=k.Ay.div(o||(o=(0,A.A)(["\n  margin-bottom: 20px;\n"]))),R=k.Ay.h1(l||(l=(0,A.A)(["\n  font-size: 2rem;\n  margin-bottom: 10px;\n"]))),B=k.Ay.p(a||(a=(0,A.A)(["\n  color: ",";\n  line-height: 1.5;\n"])),e=>{let{theme:n}=e;return n.colors.textLight}),D=k.Ay.div(c||(c=(0,A.A)(["\n  display: flex;\n  gap: 10px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: center;\n"]))),P=k.Ay.button(d||(d=(0,A.A)(["\n  padding: 8px 16px;\n  background-color: ",";\n  transition: all 0.3s ease;\n  color: ",";\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  \n  &:hover {\n    background-color: ",";\n  transition: all 0.3s ease;\n  }\n  \n  &:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n"])),e=>e.primary?"#3182ce":"#e2e8f0",e=>e.primary?"white":"#4a5568",e=>e.primary?"#2c5282":"#cbd5e0"),N=k.Ay.div(h||(h=(0,A.A)(["\n  display: flex;\n  flex-direction: row;\n  gap: 20px;\n  flex-wrap: wrap;\n"]))),V=k.Ay.div(g||(g=(0,A.A)(["\n  flex: 1;\n  min-width: 500px;\n  max-width: 100%;\n  min-height: 500px;\n  border: 1px solid #e2e8f0;\n  border-radius: 8px;\n  overflow: hidden;\n  position: relative;\n"]))),I=k.Ay.canvas(m||(m=(0,A.A)(["\n  width: 100%;\n  height: 100%;\n"]))),z=k.Ay.div(p||(p=(0,A.A)(["\n  flex: 1;\n  min-width: 300px;\n  max-width: 100%;\n  background-color: #f8fafc;\n  transition: all 0.3s ease;\n  border-radius: 8px;\n  padding: 16px;\n  border: 1px solid #e2e8f0;\n"]))),O=k.Ay.h3(x||(x=(0,A.A)(["\n  font-size: 1.2rem;\n  margin-bottom: 10px;\n  padding-bottom: 8px;\n  border-bottom: 1px solid #e2e8f0;\n"]))),W=k.Ay.div(u||(u=(0,A.A)(["\n  font-size: 0.9rem;\n  line-height: 1.5;\n  color: #4a5568;\n"]))),G=k.Ay.select(f||(f=(0,A.A)(["\n  padding: 8px;\n  border-radius: 4px;\n  border: 1px solid #e2e8f0;\n  background-color: ",";\n  transition: all 0.3s ease;\n  color: #4a5568;\n"])),e=>{let{theme:n}=e;return n.colors.card}),J=k.Ay.div(v||(v=(0,A.A)(["\n  margin-top: 10px;\n  padding: 10px;\n  background-color: #FEF2F2;\n  transition: all 0.3s ease;\n  border-radius: 4px;\n  border: 1px solid #FCA5A5;\n"]))),L=k.Ay.div(y||(y=(0,A.A)(["\n  display: inline-block;\n  padding: 2px 6px;\n  margin: 2px;\n  background-color: #FEE2E2;\n  transition: all 0.3s ease;\n  border-radius: 4px;\n  font-weight: 500;\n"]))),_=()=>{const e=(0,b.useRef)(null),[n,t]=(0,b.useState)([]),[i,s]=(0,b.useState)([]),[r,o]=(0,b.useState)([]),[l,a]=(0,b.useState)([]),[c,d]=(0,b.useState)(0),[h,g]=(0,b.useState)(!1),[m,p]=(0,b.useState)(1e3),[x,u]=(0,b.useState)(6),f=(0,b.useRef)(null),v=()=>{a([]),d(0),g(!1),f.current&&(clearTimeout(f.current),f.current=null);const e=x,n=[];for(let t=0;t<e;t++){const i=2*Math.PI*t/e;n.push({id:t,x:250+180*Math.cos(i),y:250+180*Math.sin(i),name:String.fromCharCode(65+t),state:"unvisited"})}const i=[],r=Array(e).fill(null).map(()=>[]),l=(e,n)=>{i.push({from:e,to:n,state:"normal"}),r[e].push(n)};for(let t=0;t<e;t++)l(t,(t+1)%e);for(let t=0;t<e;t++)for(let n=0;n<e;n++)t!==n&&n!==(t+1)%e&&Math.random()<.15&&l(t,n);t(n),s(i),o(r),a([{vertices:[...n],edges:[...i],description:"Initial graph with cycles. We will find the minimum number of edges to remove to break all cycles.",removedEdges:[]}]),setTimeout(()=>y(),100)},y=()=>{const n=e.current;if(!n)return;const t=n.getContext("2d");if(!t)return;const i=l[c];if(!i)return;const{vertices:s,edges:r}=i;t.clearRect(0,0,n.width,n.height);for(const e of r){if("removed"===e.state)continue;const n=s[e.from],i=s[e.to],r=i.x-n.x,o=i.y-n.y,l=Math.sqrt(r*r+o*o),a=r/l,c=o/l,d=n.x+20*a,h=n.y+20*c,g=i.x-20*a,m=i.y-20*c;switch(e.state){case"normal":t.strokeStyle="#A0AEC0";break;case"discovery":t.strokeStyle="#3182CE";break;case"back":t.strokeStyle="#E53E3E";break;case"permanent":t.strokeStyle="#38A169"}t.lineWidth=2,t.beginPath(),t.moveTo(d,h),t.lineTo(g,m),t.stroke();const p=10,x=Math.atan2(m-h,g-d);t.beginPath(),t.moveTo(g,m),t.lineTo(g-p*Math.cos(x-Math.PI/6),m-p*Math.sin(x-Math.PI/6)),t.lineTo(g-p*Math.cos(x+Math.PI/6),m-p*Math.sin(x+Math.PI/6)),t.closePath(),t.fillStyle=t.strokeStyle,t.fill()}for(const e of r){if("removed"!==e.state)continue;const n=s[e.from],i=s[e.to],r=i.x-n.x,o=i.y-n.y,l=Math.sqrt(r*r+o*o),a=r/l,c=o/l,d=n.x+20*a,h=n.y+20*c,g=i.x-20*a,m=i.y-20*c;t.strokeStyle="#F56565",t.setLineDash([4,2]),t.lineWidth=1,t.beginPath(),t.moveTo(d,h),t.lineTo(g,m),t.stroke(),t.setLineDash([])}for(const e of s){switch(e.state){case"unvisited":t.fillStyle="#E2E8F0";break;case"visiting":t.fillStyle="#4299E1";break;case"visited":t.fillStyle="#2B6CB0";break;case"sorted":t.fillStyle="#38A169"}t.beginPath(),t.arc(e.x,e.y,20,0,2*Math.PI),t.fill(),t.strokeStyle="#2D3748",t.lineWidth=1,t.stroke(),t.font="16px Arial",t.fillStyle="#FFFFFF",t.textAlign="center",t.textBaseline="middle",t.fillText(e.name,e.x,e.y)}};(0,b.useEffect)(()=>{v()},[x]),(0,b.useEffect)(()=>{n.length>0&&i.length>0&&(()=>{let e=JSON.parse(JSON.stringify(n)),t=JSON.parse(JSON.stringify(i));const s=JSON.parse(JSON.stringify(r)),o=[{vertices:[...e],edges:[...t],description:"Starting to find the minimum feedback arc set using DFS and greedy removal of back edges.",removedEdges:[]}],l=[],c=()=>{e=e.map(e=>(0,j.A)((0,j.A)({},e),{},{state:"unvisited"})),o.push({vertices:[...e],edges:[...t],description:"Starting DFS to identify back edges in the graph.",removedEdges:[...l]});const i=Array(n.length).fill(!1);let r=!1;const a=n=>{e=e.map((e,t)=>t===n?(0,j.A)((0,j.A)({},e),{},{state:"visiting"}):e),i[n]=!0,o.push({vertices:[...e],edges:[...t],description:"Visiting vertex ".concat(e[n].name,". Adding to recursion stack."),removedEdges:[...l]});for(const c of[...s[n]]){const d=t.findIndex(e=>e.from===n&&e.to===c&&"removed"!==e.state);if(-1!==d)if("unvisited"===e[c].state)t=t.map((e,n)=>n===d?(0,j.A)((0,j.A)({},e),{},{state:"discovery"}):e),o.push({vertices:[...e],edges:[...t],description:"Exploring edge from ".concat(e[n].name," to ").concat(e[c].name,"."),removedEdges:[...l]}),a(c)&&(r=!0);else if(i[c]){t=t.map((e,n)=>n===d?(0,j.A)((0,j.A)({},e),{},{state:"back"}):e);const i=(0,j.A)({},t[d]);l.push(i),t=t.map((e,n)=>n===d?(0,j.A)((0,j.A)({},e),{},{state:"removed"}):e),s[n]=s[n].filter(e=>e!==c),o.push({vertices:[...e],edges:[...t],description:"Cycle detected! Found back edge from ".concat(e[n].name," to ").concat(e[c].name,". This edge will be removed to break the cycle."),removedEdges:[...l]}),r=!0}}return e=e.map((e,t)=>t===n?(0,j.A)((0,j.A)({},e),{},{state:"visited"}):e),i[n]=!1,o.push({vertices:[...e],edges:[...t],description:"Finished exploring vertex ".concat(e[n].name,". Removing from recursion stack."),removedEdges:[...l]}),r};let c=!1;for(let n=0;n<e.length;n++)"unvisited"===e[n].state&&a(n)&&(c=!0);return c};let h=0;for(;c()&&h<5;)o.push({vertices:[...e],edges:[...t],description:"Iteration ".concat(h+1," complete. Checking if there are still cycles in the graph."),removedEdges:[...l]}),h++;t=t.map(e=>"removed"!==e.state?(0,j.A)((0,j.A)({},e),{},{state:"permanent"}):e),o.push({vertices:[...e],edges:[...t],description:"Algorithm complete. Removed ".concat(l.length," edge").concat(1!==l.length?"s":""," to break all cycles. The resulting graph is a Directed Acyclic Graph (DAG)."),removedEdges:[...l]}),a(o),d(0)})()},[n,i]),(0,b.useEffect)(()=>(h&&c<l.length-1?f.current=setTimeout(()=>{d(e=>e+1)},m):h&&c>=l.length-1&&g(!1),()=>{f.current&&clearTimeout(f.current)}),[h,c,l,m]),(0,b.useEffect)(()=>{y()},[c]),(0,b.useEffect)(()=>{const n=e.current;n&&(n.width=n.offsetWidth,n.height=n.offsetHeight,y());const t=()=>{n&&(n.width=n.offsetWidth,n.height=n.offsetHeight,y())};return window.addEventListener("resize",t),()=>{window.removeEventListener("resize",t)}},[]);const A=l[c];return(0,S.jsxs)(C,{children:[(0,S.jsx)(F,{children:(0,S.jsxs)(T,{to:"/algorithms",children:[(0,S.jsx)(w.QVr,{style:{marginRight:"8px"}})," Back to Algorithms"]})}),(0,S.jsxs)(M,{children:[(0,S.jsx)(R,{children:"Minimum Edges to Remove to Break All Cycles"}),(0,S.jsx)(B,{children:"Learn how to find the minimum number of edges to remove from a directed graph to make it acyclic. This is known as the Feedback Arc Set problem, and it has many applications in scheduling, circuit design, and more."})]}),(0,S.jsxs)(D,{children:[(0,S.jsxs)(G,{value:x,onChange:e=>u(Number(e.target.value)),children:[(0,S.jsx)("option",{value:"4",children:"4 Vertices"}),(0,S.jsx)("option",{value:"5",children:"5 Vertices"}),(0,S.jsx)("option",{value:"6",children:"6 Vertices"}),(0,S.jsx)("option",{value:"7",children:"7 Vertices"}),(0,S.jsx)("option",{value:"8",children:"8 Vertices"})]}),(0,S.jsxs)(P,{onClick:v,children:[(0,S.jsx)(w.Swo,{})," New Graph"]}),(0,S.jsxs)(G,{value:m,onChange:e=>p(Number(e.target.value)),children:[(0,S.jsx)("option",{value:"2000",children:"Slow"}),(0,S.jsx)("option",{value:"1000",children:"Normal"}),(0,S.jsx)("option",{value:"500",children:"Fast"})]}),h?(0,S.jsxs)(P,{primary:!0,onClick:()=>{g(!1)},children:[(0,S.jsx)(w.kwt,{})," Pause"]}):(0,S.jsxs)(P,{primary:!0,onClick:()=>{c>=l.length-1&&d(0),g(!0)},children:[(0,S.jsx)(w.gSK,{})," Start"]}),(0,S.jsxs)(P,{onClick:()=>{c>0&&d(e=>e-1)},disabled:0===c,children:[(0,S.jsx)(w.ttb,{})," Back"]}),(0,S.jsxs)(P,{onClick:()=>{c<l.length-1&&d(e=>e+1)},disabled:c===l.length-1,children:[(0,S.jsx)(w.FH8,{})," Forward"]}),(0,S.jsx)(P,{onClick:()=>{g(!1),d(0)},children:"Reset"})]}),(0,S.jsxs)(N,{children:[(0,S.jsx)(V,{children:(0,S.jsx)(I,{ref:e,width:500,height:500})}),(0,S.jsxs)(z,{children:[(0,S.jsx)(O,{children:"Current Step"}),(0,S.jsxs)(W,{children:[(null===A||void 0===A?void 0:A.description)||"Initializing...",(null===A||void 0===A?void 0:A.removedEdges.length)>0&&(0,S.jsxs)(J,{children:[(0,S.jsx)("p",{children:(0,S.jsx)("strong",{children:"Removed Edges:"})}),A.removedEdges.map((e,t)=>{var i,s;return(0,S.jsxs)(L,{children:[null===(i=n[e.from])||void 0===i?void 0:i.name," \u2192 ",null===(s=n[e.to])||void 0===s?void 0:s.name]},t)})]})]}),(0,S.jsx)(O,{children:"How It Works"}),(0,S.jsxs)(W,{children:[(0,S.jsx)("p",{children:"The algorithm finds a minimum feedback arc set (FAS) - the smallest set of edges to remove to make a directed graph acyclic."}),(0,S.jsx)("p",{children:"Steps:"}),(0,S.jsxs)("ol",{children:[(0,S.jsx)("li",{children:"Run a DFS to find back edges that form cycles."}),(0,S.jsx)("li",{children:"Remove those back edges to break cycles."}),(0,S.jsx)("li",{children:"Continue until no cycles remain."})]}),(0,S.jsx)("p",{children:"Color coding:"}),(0,S.jsxs)("ul",{children:[(0,S.jsxs)("li",{children:[(0,S.jsx)("span",{style:{color:"#E2E8F0"},children:"\u25a0"})," White: Unvisited vertices"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("span",{style:{color:"#4299E1"},children:"\u25a0"})," Blue: Vertices currently being visited"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("span",{style:{color:"#2B6CB0"},children:"\u25a0"})," Dark Blue: Visited vertices"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("span",{style:{color:"#A0AEC0"},children:"\u27a1"})," Gray: Normal edges"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("span",{style:{color:"#3182CE"},children:"\u27a1"})," Blue: Discovery edges"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("span",{style:{color:"#E53E3E"},children:"\u27a1"})," Red (solid): Back edges forming cycles"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("span",{style:{color:"#F56565"},children:"- - -"})," Red (dashed): Removed edges"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("span",{style:{color:"#38A169"},children:"\u27a1"})," Green: Edges in the resulting DAG"]})]})]}),(0,S.jsx)(O,{children:"Time and Space Complexity"}),(0,S.jsxs)(W,{children:[(0,S.jsxs)("p",{children:[(0,S.jsx)("strong",{children:"Time Complexity:"})," O(V\xb7(V+E)) where V is the number of vertices and E is the number of edges. This is because we may need to run DFS multiple times (up to V times in the worst case) to remove all cycles."]}),(0,S.jsxs)("p",{children:[(0,S.jsx)("strong",{children:"Space Complexity:"})," O(V+E) for the graph representation and recursion stack."]}),(0,S.jsx)("p",{children:"Note: Finding the minimum feedback arc set is actually NP-hard in general, so this greedy algorithm may not always give the optimal solution, but it works well in practice."})]}),(0,S.jsx)(O,{children:"Applications"}),(0,S.jsx)(W,{children:(0,S.jsxs)("ul",{children:[(0,S.jsxs)("li",{children:[(0,S.jsx)("strong",{children:"Scheduling Problems:"})," Converting cyclic dependencies into linear ordering"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("strong",{children:"Circuit Design:"})," Breaking feedback loops in electronic circuits"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("strong",{children:"Dependency Resolution:"})," Resolving circular dependencies in software packages"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("strong",{children:"Deadlock Prevention:"})," Breaking potential deadlocks in resource allocation"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("strong",{children:"Tournament Rankings:"})," Creating a consistent ranking from incomplete tournament results"]}),(0,S.jsxs)("li",{children:[(0,S.jsx)("strong",{children:"Biology:"})," Analyzing regulatory networks in gene expression"]})]})})]})]})]})}}}]);